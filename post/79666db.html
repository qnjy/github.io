<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qnjy.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="第一章 绪论1.1 数据结构的基本概念 数据结构 （三要素）\begin{cases}逻辑结构\begin{cases}线性结构：线性表、栈、队列\\\\ 非线性结构：数，图，集合\end{cases}\\\\ 存储结构（物理结构）\\\\ 数据的运算\end{cases} 1.2 算法的基本概念1.2.1 时间复杂度　　事前预估算法时间开销T(n)与问题规模n的关系。分析算法操作的执行次数x和问">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://qnjy.github.io/post/79666db.html">
<meta property="og:site_name" content="qnjy&#39;s blog">
<meta property="og:description" content="第一章 绪论1.1 数据结构的基本概念 数据结构 （三要素）\begin{cases}逻辑结构\begin{cases}线性结构：线性表、栈、队列\\\\ 非线性结构：数，图，集合\end{cases}\\\\ 存储结构（物理结构）\\\\ 数据的运算\end{cases} 1.2 算法的基本概念1.2.1 时间复杂度　　事前预估算法时间开销T(n)与问题规模n的关系。分析算法操作的执行次数x和问">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714093923732.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/6boW7T.jpg">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220706095637004.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/6bo3fH.jpg">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220813114207888.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220813215922832.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220813220007126.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220705221144272.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220813223311649.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220705220904375.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220814100148426.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220814101436197.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220814102641290.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220814223349227.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220814224100990.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220706093630538.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815091958524.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220706093540274.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220706093946066.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220921205055431.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815172205204.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815182649345.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815172229701.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1620868011-image-20210513090651272.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1620868285-image-20210513091125197.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1I33AU8-0.gif">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815181235440.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815181450809.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220708090638224.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220708090820199.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220708090938288.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815172419389.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711085301857.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711085453549.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711090031520.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711090810128.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711105659430.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711105959849.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711110533027.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711205957456.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711210827504.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711211758907.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711213135231.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220711213233762.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712084132483.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712085153458.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712085743563.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712090141737.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712090146582.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712093936345.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712094144507.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712104045770.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712111109308.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712111118458.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712104336797.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712105008432.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712105738017.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712110532903.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712111433819.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712151124937.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/SmartSelect_20220911-171036_Samsung%20Notes.jpg">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712200914670.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617786835-image-20210407171355733.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712202935008.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712203210512.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712203822313.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617844641-image-20210408091721508.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617876251-image-20210408180411607.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617876268-image-20210408180428251.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617876532-image-20210408180852817.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617876541-image-20210408180901861.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220712210501560.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220701221609629.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714095417721.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617786182-image-20210407170302561.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617786227-image-20210407170347593.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617786252-image-20210407170412791.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1617788435-image-20210407174035666.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619053575-image-20210422090614930.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619053611-image-20210422090651292.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619053789-image-20210422090949365.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619053809-image-20210422091009192.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/2012031419192993.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220713093134719.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618393158-image-20210414173918248.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220713093936717.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714090240972.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714090517756.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714091725908.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714091520838.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714091431926.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220714092026037.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618445484-image-20210415081124676.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618445972-image-20210415081932478.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618446095-image-20210415082134980.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618446122-image-20210415082202662.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619055375-image-20210422093615176.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210603-image-20210603093907428.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210603-image-20210603095305745.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618999001-image-20210421175641281.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618998974-image-20210421175614149.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618999143-image-20210421175903730.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1618999151-image-20210421175911065-165718535507438.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619599276-image-20210428164116694.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619599384-image-20210428164304480.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619599429-image-20210428164349664.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619599481-image-20210428164441752.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619599589-image-20210428164628941.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619599660-image-20210428164740239.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619600884-image-20210428170804280.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619601939-image-20210428172539618.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/1619655052-image-20210429081052350.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220715212455370.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220715212302470.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220715213701703.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220715214255303.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220715214709815.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220720155802492.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220720160114186.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220720160848637.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210602-image-20210602230209346.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210602-image-20210602230310978.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220725100148632.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220725100210983.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220720215259505.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220725150523041.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220725103236328.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220721174159591.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220724170023428.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220922163420309.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220922164016078.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220922164253274.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220922164543414.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220922164709356.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220922165034160.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220922165107744.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220724172040671.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220926093651305.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220724173535397.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220724204617958.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210526-image-20210526175341516.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527080726469.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527081029408.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527081355420.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527081640790.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527081706164.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527081850609.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527081924315.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527081948695.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527082030489.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527082102010.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527082126473.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527082230583.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527082324312.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527082352452.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220725151333348.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220725155319842.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220725155508510.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726090101528.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726092247462.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726093422052.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726093208933.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726093718931.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726094638224.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726151146053.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726151355361.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220726151836813.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527094036260.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220720200950589.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527091618326.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527091709212.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/20210527-image-20210527091738713.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220701211121971.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220701204947055.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220701205042641.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220701205621919.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220701212338821.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220702211601835.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220702211703123.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220702211744851.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220702211950125.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220702222731538.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703201839995.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703201856707.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703202009127.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703202107684.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703204405241.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703205953193.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703210139247.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703211238539.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703211311373.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703212400232.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703214449902.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703214811189.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703215954764.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703220015875.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703220027885.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703222317866.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220703222542602.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/QQ截图20220919102243.jpg">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815211558114.png">
<meta property="og:image" content="https://qnjy.github.io/images/数据结构/image-20220815184309588.png">
<meta property="article:published_time" content="2021-03-14T02:18:29.000Z">
<meta property="article:modified_time" content="2022-09-26T01:36:51.492Z">
<meta property="article:author" content="qnjy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qnjy.github.io/images/数据结构/image-20220714093923732.png">


<link rel="canonical" href="https://qnjy.github.io/post/79666db.html">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构 | qnjy's blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">qnjy's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">方向不对，努力白费</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="nav-text">第一章 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1 数据结构的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1.2 算法的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.2.1 时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.2.2 空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">第二章 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AF%B9%E6%AF%94"><span class="nav-text">顺序表和链表对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 线性表的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1.1 数学定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">2.1.2 线性表的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">2.2 线性表的存储方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">2.3 顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">2.3.1 顺序表的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">2.3.2 顺序表的基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">2.4 单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.4.1 单链表的基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">2.5 双链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-text">2.6 循环链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">2.6.1 循环单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">2.6.2 循环双链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">2.7 静态链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">2.8 广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.8.1 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">2.8.2 广义表的性质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">第三章 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 栈的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-text">3.2 顺序栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">3.2.1 顺序栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">3.2.2 顺序栈的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E5%85%B1%E4%BA%AB%E6%A0%88%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%A0%88%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98"><span class="nav-text">3.2.3 共享栈：解决栈大小不可改变</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E9%93%BE%E6%A0%88"><span class="nav-text">3.3 链栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E9%93%BE%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">3.3.1 链栈的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.4 队列的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">3.4.1 队列的顺序存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">3.4.2 队列的链式存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-text">3.4.3 双端队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">3.5 栈和队列的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E6%A0%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-text">3.5.1 栈的括号匹配问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E6%A0%88%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">3.5.2 栈的表达式求值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">3.6 队列的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-text">3.6.1 用队列实现树的层次遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">3.6.2 用队列实现图的广度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">3.7 特殊矩阵的压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-%E6%95%B0%E7%BB%84"><span class="nav-text">3.7.1 数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8"><span class="nav-text">3.7.2 对称矩阵存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-3-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">3.7.3 三角矩阵的压缩存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-4-%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="nav-text">3.7.4 三对角矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-5-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">3.7.5 稀疏矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2"><span class="nav-text">第四章 串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">4.1 串的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">4.2 串的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">4.2.1 串的顺序存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">4.2.2 串的链式存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">4.3 字符串的模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E6%9A%B4%E5%8A%9B%E5%BE%AA%E7%8E%AF"><span class="nav-text">4.3.1 暴力循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-KMP%E7%AE%97%E6%B3%95"><span class="nav-text">4.3.2 KMP算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-KMP%E4%BC%98%E5%8C%96"><span class="nav-text">4.3.3 KMP优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">第五章 树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%A0%91"><span class="nav-text">5.1 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1.1 树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">5.1.2 树的基本术语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.2 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.2.1 二叉树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">5.2.2 二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.2.3 特殊的二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.2.4 二叉树的存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.3 遍历二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.3.1 先序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.3.2 中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.3.3 后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-4-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.3.4 层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%BA%94%E7%94%A8"><span class="nav-text">5.3.5 二叉树的遍历应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.4 线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="nav-text">5.4.1 中序线索化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="nav-text">5.4.2 先序线索化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-3-%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="nav-text">5.5.3 后序线索化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E6%A3%AE%E6%9E%97%E4%B8%8E%E6%A0%91"><span class="nav-text">5.5 森林与树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.5.1 树的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">5.5.2 森林和二叉树的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-3-%E6%A3%AE%E6%9E%97%E5%92%8C%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">5.5.3 森林和树的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-text">5.6 哈夫曼树及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-1-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">5.6.1 哈夫曼树的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="nav-text">5.6.2 哈夫曼树的构造算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE"><span class="nav-text">第六章 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">6.1 图的定义和基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">6.1.1 图的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">6.1.2 图的基本术语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.2 图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="nav-text">6.2.1 邻接矩阵法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="nav-text">6.2.2  邻接表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95%E5%92%8C%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-text">6.2.3 十字链表法和邻接多重表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">6.2.4 图的基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">6.3 图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">6.3.1 深度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">6.3.2 广度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">6.4 图的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">6.4.1 最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-text">6.4.2 最短路径问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0%EF%BC%9A%E8%8B%A5%E5%85%81%E8%AE%B8%E5%9C%A8-v-0-%E4%B8%AD%E8%BD%AC%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%BA%EF%BC%9F"><span class="nav-text">0：若允许在$v_0$中转，最短路径为？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1%EF%BC%9A%E8%8B%A5%E5%85%81%E8%AE%B8%E5%9C%A8-v-0%E3%80%81v-1-%E4%B8%AD%E8%BD%AC%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%BA%EF%BC%9F"><span class="nav-text">1：若允许在$v_0、v_1$中转，最短路径为？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2%EF%BC%9A%E8%8B%A5%E5%85%81%E8%AE%B8%E5%9C%A8-v-0%E3%80%81v-1%E3%80%81v-2-%E4%B8%AD%E8%BD%AC%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%BA%EF%BC%9F"><span class="nav-text">2：若允许在$v_0、v_1、v_2$中转，最短路径为？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#n-1%EF%BC%9A%E8%8B%A5%E5%85%81%E8%AE%B8%E5%9C%A8-v0%E3%80%81v-1%E3%80%81v-2%E2%80%A6v-n-1-%E4%B8%AD%E8%BD%AC%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%BA%EF%BC%9F"><span class="nav-text">n-1：若允许在$v0、v_1、v_2…v{n-1}$中转，最短路径为？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="nav-text">6.4.3 有向无环图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-AOV-%E7%BD%91"><span class="nav-text">6.4.4 AOV 网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-5-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">6.4.5 拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-6-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">6.4.6 关键路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="nav-text">第七章 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">7.1 查找的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2 线性表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2.1 顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2.2 折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2.3 分块查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">7.3 树表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="nav-text">7.3.1 二叉排序树（BST）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">7.3.2 平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-B%E6%A0%91"><span class="nav-text">7.3.3 B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-B-%E6%A0%91"><span class="nav-text">7.3.4 B+树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="nav-text">7.4 散列查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-%E6%95%A3%E5%88%97%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">7.4.1 散列表基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%BA%E4%BA%86%E4%BD%BF%E5%86%B2%E7%AA%81%E5%87%8F%E5%B0%91%EF%BC%89"><span class="nav-text">7.4.2 常见的散列函数（为了使冲突减少）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="nav-text">第八章 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1.1 直接插入方法排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1.2 折半插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1.3 希尔排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-text">8.2 交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">8.2.1 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">8.2.2 快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3.1 简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-%E6%A0%91%E5%BD%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3.2 树形选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3.3 堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">8.4 归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">8.5 基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-text">8.6 外部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-1-%E8%B4%A5%E8%80%85%E6%A0%91"><span class="nav-text">8.6.1 败者树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-2-%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.6.2 置换-选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-3-%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="nav-text">8.6.3 最佳归并树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86%EF%BC%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%98%AF%E5%90%A6%E5%B8%A6%E2%80%9C-amp-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">小知识：函数参数是否带“&amp;”的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">各个数据类型的定义结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">1 顺序表的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">2 链表的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">2.1 单链表的基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">3 栈的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%85%B1%E4%BA%AB%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">4 共享栈的基本操作</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="qnjy"
      src="/images/xigua.jpg">
  <p class="site-author-name" itemprop="name">qnjy</p>
  <div class="site-description" itemprop="description">宁静以致远</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qnjy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qnjy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:877900490@qq.com" title="E-Mail → mailto:877900490@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>

    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qnjy.github.io/post/79666db.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/xigua.jpg">
      <meta itemprop="name" content="qnjy">
      <meta itemprop="description" content="宁静以致远">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qnjy's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 10:18:29" itemprop="dateCreated datePublished" datetime="2021-03-14T10:18:29+08:00">2021-03-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-09-26 09:36:51" itemprop="dateModified" datetime="2022-09-26T09:36:51+08:00">2022-09-26</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h2><script type="math/tex; mode=display">
数据结构 （三要素）\begin{cases}逻辑结构\begin{cases}线性结构：线性表、栈、队列\\\\
非线性结构：数，图，集合\end{cases}\\\\
存储结构（物理结构）\\\\
数据的运算\end{cases}</script><p><img src="../../../images/数据结构/image-20220714093923732.png" alt="image-20220714093923732"></p>
<h2 id="1-2-算法的基本概念"><a href="#1-2-算法的基本概念" class="headerlink" title="1.2 算法的基本概念"></a>1.2 算法的基本概念</h2><h2 id="1-2-1-时间复杂度"><a href="#1-2-1-时间复杂度" class="headerlink" title="1.2.1 时间复杂度"></a>1.2.1 时间复杂度</h2><p>　　事前预估算法时间开销T(n)与问题规模n的关系。分析算法操作的执行次数x和问题模型n的关系x=f(n)。<span id="more"></span></p>
<p><strong>常见数量级关系</strong>：（常对幂指阶）</p>
<script type="math/tex; mode=display">
O(1)<O(\log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script><p><img src="../../../images/数据结构/6boW7T.jpg" alt="6boW7T" style="zoom: 80%;" /></p>
<h3 id="1-2-2-空间复杂度"><a href="#1-2-2-空间复杂度" class="headerlink" title="1.2.2 空间复杂度"></a>1.2.2 空间复杂度</h3><p>　　无论问题规模怎么变，算法运行所需的内存空间都是固定的常量。</p>
<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="顺序表和链表对比"><a href="#顺序表和链表对比" class="headerlink" title="顺序表和链表对比"></a>顺序表和链表对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>支持随机存储，存储密度高</td>
<td>不需要使用地址连续的存储单元</td>
</tr>
<tr>
<td>缺点</td>
<td>插入和删除操作需要移动大量元素</td>
<td>不可随机存储，存储密度低</td>
</tr>
</tbody>
</table>
</div>
<p><img src="../../../images/数据结构/image-20220706095637004.png" alt="image-20220706095637004"></p>
<h2 id="2-1-线性表的基本概念"><a href="#2-1-线性表的基本概念" class="headerlink" title="2.1 线性表的基本概念"></a>2.1 线性表的基本概念</h2><p>　　由<font color="ff0000">零个或多个相同数据类型的</font>数据元素组成的<font color="ff0000">有限</font>序列。 </p>
<p>　　特性：有序，类型相同，有限。</p>
<h3 id="2-1-1-数学定义"><a href="#2-1-1-数学定义" class="headerlink" title="2.1.1 数学定义"></a>2.1.1 数学定义</h3><p>　　线性表是具有相同类型的n(n≥0)个数据元素的有限序列（a1,a2,a3,…,an-1,an），ai是表项，n是表长度。存在前驱后继。</p>
<h3 id="2-1-2-线性表的操作"><a href="#2-1-2-线性表的操作" class="headerlink" title="2.1.2 线性表的操作"></a>2.1.2 线性表的操作</h3><ul>
<li>创建线性表</li>
<li>销毁线性表</li>
<li>清空线性表</li>
<li>将元素插入线性表</li>
<li>将元素从线性表中删除</li>
<li>获取线性表中某个位置的元素</li>
<li>获取线性表的长度</li>
</ul>
<p>线性表的抽象数据类型定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ADT线性表（List）</span><br><span class="line">    </span><br><span class="line">Data</span><br><span class="line">　　线性表的数据对象集合为&#123;a1,a2,a3,...,an<span class="number">-1</span>,an&#125;，其中，除第一个元素a1外，每个元素有且只有一个直接前驱元素，直接后继元素同理，数据元素之间的关系是一一对应的。</span><br><span class="line">    </span><br><span class="line">Operation（操作）</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，建立一个空的线性表L</span></span><br><span class="line">InitList(&amp;L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若线性表为空，返回true，否则返回false</span></span><br><span class="line">ListEmpty(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将线性表清空</span></span><br><span class="line">ClearList(&amp;L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将线性表L中的第i个位置的元素返回</span></span><br><span class="line">GetElem(L,i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，否则返回0表示失败</span></span><br><span class="line">LocateElem(L,e)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表L中的第i个位置插入新元素e</span></span><br><span class="line">ListInsert(&amp;L,i,e);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除线性表L中的第i个位置元素，并用e返回其值</span></span><br><span class="line">ListDelete(&amp;L,i,&amp;e);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回线性表L的元素个数</span></span><br><span class="line">ListLength(L);;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line">DestroyList(&amp;L);</span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>&amp;符号，对参数修改的结果需要“带回来”</p>
<h2 id="2-2-线性表的存储方式"><a href="#2-2-线性表的存储方式" class="headerlink" title="2.2 线性表的存储方式"></a>2.2 线性表的存储方式</h2><p><img src="../../../images/数据结构/6bo3fH.jpg" alt="6bo3fH" style="zoom:67%;" /></p>
<p>如上图，线性表的存储细分以下两种：</p>
<p>1.将所有数据一次存储在连续的整块屋里空间中，叫做<font color="#008000">顺序存储结构</font>；</p>
<p>2.数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，<font color="#008000">链式存储结构</font>。</p>
<h2 id="2-3-顺序表"><a href="#2-3-顺序表" class="headerlink" title="2.3 顺序表"></a>2.3 顺序表</h2><h3 id="2-3-1-顺序表的概念"><a href="#2-3-1-顺序表的概念" class="headerlink" title="2.3.1 顺序表的概念"></a>2.3.1 顺序表的概念</h3><p>　　顺序表不仅存在“一对一”的数据关系，对数据的物理存储结构也有要求。<font color="#b22222">顺序表存储结构时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝细缝</font>。</p>
<p>优缺点：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机访问，既可以在O(1)的时间内找到第i个元素</td>
<td>插入和删除操作需要移动大量元素</td>
</tr>
<tr>
<td>无需为表示元素之间的逻辑关系而增加额外的存储空间</td>
<td>当线性表长度变化较大时，难以确定存储空间的容量</td>
</tr>
<tr>
<td>逻辑关系相邻，物理位置相邻</td>
<td>分配空间需按固定大小分配，利用不充分</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-2-顺序表的基本操作"><a href="#2-3-2-顺序表的基本操作" class="headerlink" title="2.3.2 顺序表的基本操作"></a>2.3.2 顺序表的基本操作</h3><p>可以运行的完整代码：<a href="#1 顺序表的基本操作">附录-顺序表的基本操作</a></p>
<p><strong>1.顺序表初始化</strong></p>
<p>顺序表需要实时记录一下两项数据：</p>
<ul>
<li>顺序表申请的存储容量；</li>
<li>顺序表的长度，也就是表中存储数据元素的个数；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度</span><br></pre></td></tr></table></figure>
<p>因此，需要自定义顺序表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqList</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];<span class="comment">//声明data数组，长度为10</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//记录当前顺序表的长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10 <span class="comment">//默认最大容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;<span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;<span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>
<p>初步建立一个顺序表，需要如下工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">        L.data[i]=<span class="number">0</span>;<span class="comment">//将所有数据元素初始值为0</span></span><br><span class="line">    L.length=<span class="number">0</span>;<span class="comment">//初始化顺序表长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.data=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = L.data;</span><br><span class="line">    L.data=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        L.data[i]=p[i];<span class="comment">//将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize=L.MaxSize+len;<span class="comment">//顺序表最大长度增加len</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放原来内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.顺序表的插入元素</strong></p>
<blockquote>
<p>在线性表的第i个位置插入元素e</p>
</blockquote>
<p>需要注意</p>
<ul>
<li>如果插入位置==不合理==，或者线性表长度$\ge$数组长度，应抛出异常</li>
<li>从最后一个数向前遍历到第i个位置，分别将他们==向后==移动一个位置</li>
<li>将插入元素==填在i处==</li>
<li>表长==+1==</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在L的i处插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)<span class="comment">//判断i是否在顺序表长度内</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= MaxSize) &#123;<span class="comment">//当前存储空间已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; --j) &#123;<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;<span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;<span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：</p>
<p>$\begin{cases}最好情况：新元素插入到表尾不需要移动元素，i=n+1,循环0次，O(1)\\最坏情况：插入到表头，n个元素全部向后移动，i=1，循环n次；O(n)\\平均情况：插入到任意位置概率相同p=\frac{1}{n+1}，则循环次数=np+(n-1)p+……+1·p=\frac{n(n+1)}{2}=\frac{n}{2},O(\frac{n}{2})\end{cases}  $</p>
<p><strong>3.顺序表的删除元素</strong></p>
<blockquote>
<p>删除第i个位置的元素，==注意比如要删除第5个数，需要将访问的下标为4==</p>
</blockquote>
<ul>
<li>删除位置==不合理==，抛出异常</li>
<li>==取出==删除元素</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将他们==向前==移动一个位置</li>
<li>表长==-1==</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在L的i处删除元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断i是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;L.length ; ++j)<span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    <span class="comment">//表长-1</span></span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 顺序表的查找元素</strong></p>
<p>查找元素可以使用多种查找算法，比如二分查找、插值查找算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第i个元素</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.顺序表的更改元素</strong></p>
<p>实现过程：</p>
<ul>
<li>找到目标元素</li>
<li>直接修改元素的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更改函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listAmend</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> e, <span class="keyword">int</span> newElem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add = locateElem(L, e);</span><br><span class="line">    <span class="keyword">if</span> (add == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表中没有找到目标元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[add - <span class="number">1</span>] = newElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-单链表"><a href="#2-4-单链表" class="headerlink" title="2.4 单链表"></a>2.4 单链表</h2><p>只能从头结点依次顺序的向后遍历</p>
<p><img src="../../../images/数据结构/image-20220813114207888.png" alt="image-20220813114207888"></p>
<p>区别：</p>
<ul>
<li><p>带头节点（L-&gt;next==NULL是空）</p>
<p><img src="../../../images/数据结构/image-20220813215922832.png" alt="image-20220813215922832"></p>
</li>
<li><p>不带头节点（L==NULL是空）</p>
<p><img src="../../../images/数据结构/image-20220813220007126.png" alt="image-20220813220007126" style="zoom: 67%;" /></p>
</li>
</ul>
<p><a href="#2.1 单链表的基本操作">详情代码</a></p>
<h3 id="2-4-1-单链表的基本概念"><a href="#2-4-1-单链表的基本概念" class="headerlink" title="2.4.1 单链表的基本概念"></a>2.4.1 单链表的基本概念</h3><p>适合频繁的==插入，删除，更新==元素</p>
<p>特点：</p>
<ul>
<li>不要求大片连续空间，改变容量方便</li>
<li>不可随机存取，要耗费一定空间存放指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p>LNode是强调一个节点；LinkList强调一个指针</p>
<p><strong>1.单链表的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化,不带头节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，带头节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.单链表的建立</strong></p>
<p><strong>头插法</strong>：头插法构造单链表时一直往单链表的头部插入结点</p>
<p><img src="../../../images/数据结构/image-20220705221144272.png" alt="image-20220705221144272"></p>
<p><img src="../../../images/数据结构/image-20220813223311649.png" alt="image-20220813223311649" style="zoom: 80%;" /></p>
<p><strong>尾插法</strong>：一直往单链表的尾部插入结点</p>
<p><img src="../../../images/数据结构/image-20220705220904375.png" alt="image-20220705220904375"></p>
<p><strong>3.单链表的插入</strong></p>
<p><img src="../../../images/数据结构/image-20220814100148426.png" alt="image-20220814100148426"></p>
<p>找到第i个结点前一个结点的另一种方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;<span class="comment">//i值不合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的插入，带头节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j;<span class="comment">//p指向第几个节点</span></span><br><span class="line"></span><br><span class="line">    p = L;<span class="comment">//L指向头结点</span></span><br><span class="line">    <span class="comment">//找到第i个节点的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;插入位置无效&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//将节点连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的插入，不带头节点</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = L;</span><br><span class="line">    L = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>前插操作：</p>
<p><img src="../../../images/数据结构/image-20220814101436197.png" alt="image-20220814101436197"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作，在p节点前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)<span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.单链表的删除</strong></p>
<p><img src="../../../images/数据结构/image-20220814102641290.png" alt="image-20220814102641290"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    LNode *next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表删除，带头节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkListDelete</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    while (p!=NULL &amp;&amp; j&lt;i-1)&#123;</span></span><br><span class="line"><span class="comment">        p=p-&gt;next;</span></span><br><span class="line"><span class="comment">        j++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //i值不合法或者第i-1个节点就是最后一个节点</span></span><br><span class="line"><span class="comment">    if(p==NULL || p-&gt;next==NULL)</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    LNode *q = p-&gt;next;<span class="comment">//q指向被删除节点</span></span><br><span class="line">    e = q-&gt;data;<span class="comment">//e用于返回元素的值</span></span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除指定节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    p.data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.单链表的查找</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到第i个节点，按位查找</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//指向第一个数据节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-双链表"><a href="#2-5-双链表" class="headerlink" title="2.5 双链表"></a>2.5 双链表</h2><p><img src="../../../images/数据结构/image-20220814223349227.png" alt="image-20220814223349227"></p>
<p>双链表结点中有两个指针prior和next，分别指向前驱结点和后继节点；判空只需要看==head-&gt;next和head-&gt;prior==的任意一个是否为head指针即可。</p>
<p>特点：</p>
<p>不可随机存取，按位查找和按值查找只能通过遍历方式实现O(n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    DNode *prior, *next;</span><br><span class="line">&#125; DNode, *DLinkList;</span><br></pre></td></tr></table></figure>
<p><strong>1.双链表初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.双链表插入</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作，在p节点后插入s</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)<span class="comment">//如果p后是有节点的</span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.5.3 双链表删除</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p节点的后继节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)<span class="comment">//p没有后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//如果q不是最后一个节点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;<span class="comment">//修改q的前驱</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.5.4 双链表遍历</strong></p>
<p>按位查找和按值查找只能通过遍历方式实现O(n)。</p>
<h2 id="2-6-循环链表"><a href="#2-6-循环链表" class="headerlink" title="2.6 循环链表"></a>2.6 循环链表</h2><h3 id="2-6-1-循环单链表"><a href="#2-6-1-循环单链表" class="headerlink" title="2.6.1 循环单链表"></a>2.6.1 循环单链表</h3><p><img src="../../../images/数据结构/image-20220814224100990.png" alt="image-20220814224100990"></p>
<p>与单链表的区别在：最后一个结点的指针不是NULL而是改为指向头结点，形成环，判空条件是：==头指针结点的指针是否等于头指针==</p>
<p><img src="../../../images/数据结构/image-20220706093630538.png" alt="image-20220706093630538"></p>
<h3 id="2-6-2-循环双链表"><a href="#2-6-2-循环双链表" class="headerlink" title="2.6.2 循环双链表"></a>2.6.2 循环双链表</h3><p>头结点的prior指针还要指向表尾结点</p>
<p><img src="../../../images/数据结构/image-20220815091958524.png" alt="image-20220815091958524"></p>
<p><img src="../../../images/数据结构/image-20220706093540274.png" alt="image-20220706093540274"></p>
<h2 id="2-7-静态链表"><a href="#2-7-静态链表" class="headerlink" title="2.7 静态链表"></a>2.7 静态链表</h2><p><img src="../../../images/数据结构/image-20220706093946066.png" alt="image-20220706093946066"></p>
<p><strong>这里“指针”表示的是：下一个元素在数组中的位置</strong></p>
<p><strong>初始化：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-8-广义表"><a href="#2-8-广义表" class="headerlink" title="2.8 广义表"></a>2.8 广义表</h2><h3 id="2-8-1-基本概念"><a href="#2-8-1-基本概念" class="headerlink" title="2.8.1 基本概念"></a>2.8.1 基本概念</h3><p>简称表，它是线性表的推广。一个广义表是<font color = "red">n(n&gt;=0)个元素的一个序列</font>，$a<em>0,a_1,a_2,…,a</em>{n-1}$若n=0是称为空表。其中没一个$a_i$或者是原子，或者是广义表。</p>
<p>通常记作：$LS=(a_1,a_2,…,a_n)$</p>
<p>其中：LS是表名，n表示表的长度，每个$a_i$是表的元素</p>
<ul>
<li><p><strong>表头</strong>：若LS非空，则其第一个元素$a_1$就是表头</p>
<p>记作$head(LS)=a_1$。<font color="red">表头可以是原子，也可以是子表</font></p>
</li>
<li><p><strong>表尾</strong>：除表头之外的其他元素组成的表。<font color="red">表尾不是最后一个元素，而是一个子表</font></p>
<p>记作$tail(LS)=(a_2,…,a_n)$</p>
</li>
</ul>
<p><img src="../../../images/数据结构/image-20220921205055431.png" alt="image-20220921205055431" style="zoom:50%;" /></p>
<h3 id="2-8-2-广义表的性质"><a href="#2-8-2-广义表的性质" class="headerlink" title="2.8.2 广义表的性质"></a>2.8.2 广义表的性质</h3><ul>
<li><p><strong>长度</strong>：最外层所包含元素的个数；</p>
<p>如：$C=(a,(b,c))$是长度为2的广义表</p>
</li>
<li><p><strong>深度</strong>：该广义表展开后所包含括号的重数</p>
<p>如：$A=(b,c)的深度为1，B(A,d)的深度为2，C=(f,B,h)的深度为3$<font color="red">原子的深度为0，空表的深度为1</font></p>
</li>
<li><p>广义表可以和其他广义表共享。<font color="red">递归标的深度是无穷值，长度是有限值</font></p>
</li>
</ul>
<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1-栈的概念"><a href="#3-1-栈的概念" class="headerlink" title="3.1 栈的概念"></a>3.1 栈的概念</h2><p>　　栈就是一种<font color="red">只能从表的一端</font>存储数据且遵循“先进后出”原则的线性存储结构。压栈（push），弹栈（pop）。</p>
<p>栈遵循<font color="ff000">先进后出</font>，栈存储结构的实现有以下两种方式：</p>
<ul>
<li>顺序栈</li>
<li>链栈</li>
</ul>
<p><strong>栈的基本操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InitStack(&amp;S);<span class="comment">//初始化栈，构造空栈分配内存空间</span></span><br><span class="line">DestroyStack(&amp;S);<span class="comment">//销毁栈，销毁并释放</span></span><br><span class="line"></span><br><span class="line">Push(&amp;S,x);<span class="comment">//进栈</span></span><br><span class="line">Pop(&amp;S,&amp;x);<span class="comment">//出栈</span></span><br><span class="line"></span><br><span class="line">GetTop(S,&amp;x);<span class="comment">//读栈顶元素</span></span><br></pre></td></tr></table></figure>
<p>==n个不同元素进栈，出栈序列的个数为：$\frac{1}{n+1}C{^2_{2n}}=\frac{1}{n+1}\frac{(2n)!}{n!+n!}$==</p>
<p>例如：n=3，则个数为：$\frac{6×5×4}{4×3×2×1}=5$</p>
<h3 id="3-2-顺序栈"><a href="#3-2-顺序栈" class="headerlink" title="3.2 顺序栈"></a>3.2 顺序栈</h3><p><img src="../../../images/数据结构/image-20220815172205204.png" alt="image-20220815172205204"></p>
<p>特点：大小不可改变</p>
<h3 id="3-2-1-顺序栈的定义"><a href="#3-2-1-顺序栈的定义" class="headerlink" title="3.2.1 顺序栈的定义"></a>3.2.1 顺序栈的定义</h3><p>特点：给个各数据元素分配连续的存储空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   </span><br><span class="line">    ElemType data[maxsize];    <span class="comment">//定义一个数组大小为maxsize的数组，用来存放栈中数据元素    </span></span><br><span class="line">    <span class="keyword">int</span> top;              <span class="comment">//栈顶指针                 </span></span><br><span class="line">&#125;SqStack;				  <span class="comment">//顺序栈定义</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-顺序栈的操作"><a href="#3-2-2-顺序栈的操作" class="headerlink" title="3.2.2 顺序栈的操作"></a>3.2.2 顺序栈的操作</h3><p>判空s.top==-1</p>
<p>栈满s.top==maxSize-1，maxSize-1是栈满时栈顶元素在数组中的位置</p>
<p>上溢：栈满继续入栈；下溢：栈空继续出栈</p>
<p><strong>1.初始化栈S.top=-1</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top]=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.初始化栈S.top=0</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[S.top]=x;</span><br><span class="line">    S.top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top--;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-共享栈：解决栈大小不可改变"><a href="#3-2-3-共享栈：解决栈大小不可改变" class="headerlink" title="3.2.3 共享栈：解决栈大小不可改变"></a>3.2.3 共享栈：解决栈大小不可改变</h3><p><img src="../../../images/数据结构/image-20220815182649345.png" alt="image-20220815182649345"></p>
<p>初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top0;</span><br><span class="line">    <span class="keyword">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0=<span class="number">-1</span>;</span><br><span class="line">    S.top1=MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满条件：top0+1==top1</span></span><br></pre></td></tr></table></figure>
<p>以下是定义结构体实现：</p>
<p><a href="#4 共享栈的基本操作">点我查看详情代码</a></p>
<h2 id="3-3-链栈"><a href="#3-3-链栈" class="headerlink" title="3.3 链栈"></a>3.3 链栈</h2><p>把<font color="red">栈顶放在单链表的表头</font>，用链表来存储栈的数据结构称为链栈。</p>
<p><img src="../../../images/数据结构/image-20220815172229701.png" alt="image-20220815172229701"></p>
<p>链栈节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-链栈的操作"><a href="#3-3-1-链栈的操作" class="headerlink" title="3.3.1 链栈的操作"></a>3.3.1 链栈的操作</h3><p>链栈也有四个元素，包括两个状态和两个操作</p>
<p>状态：</p>
<p>1）栈空：<code>StakNode-&gt;next == NULL</code>，即栈没有后继节点时，栈为空</p>
<p>2）栈满：如果存储空间无限大，没有这种情况。</p>
<p>操作：</p>
<p>进栈是头插法建立链表的插入方法，出栈就是单链表的删除操作</p>
<p><img src="../../../images/数据结构/1620868011-image-20210513090651272.png" alt="image-20210513090651272" style="zoom: 80%;" /></p>
<p>以上是链栈的插入操作</p>
<p><img src="../../../images/数据结构/1620868285-image-20210513091125197.png" alt="image-20210513091125197" style="zoom: 80%;" /></p>
<p>以上是链栈的删除操作</p>
<ul>
<li>链栈初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造一个空栈S，栈顶指针置空</span></span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//栈顶插入元素e</span></span><br><span class="line">    p=<span class="keyword">new</span> StackNode;    <span class="comment">//创建新节点</span></span><br><span class="line">    p-&gt;data=e;          <span class="comment">//将新节点数据域置为e</span></span><br><span class="line">    p-&gt;next=S;          <span class="comment">//将新结点与头结点建立逻辑关系</span></span><br><span class="line">    S=p;                <span class="comment">//更新头结点的指向</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除S的栈顶元素，用e返回值</span></span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> ERROR;     <span class="comment">//栈空</span></span><br><span class="line">    e=S-&gt;data;            <span class="comment">//将栈顶元素赋给e</span></span><br><span class="line">    p=S;                  <span class="comment">//用p临时保存栈顶元素空间，以备释放</span></span><br><span class="line">    S=S-&gt;next;            <span class="comment">//修改栈顶指针</span></span><br><span class="line">    <span class="keyword">delete</span> p;             <span class="comment">//释放原栈顶元素的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取栈顶元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStackNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    LinkedStackNode *next;</span><br><span class="line">&#125;LinkedStackNode,*LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitLinkedStack</span><span class="params">(LinkedStack &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkedStackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStackNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyList</span><span class="params">(LinkedStack &amp;L)</span></span>&#123;</span><br><span class="line">    LinkedStack temp;</span><br><span class="line">    <span class="keyword">while</span>(L)&#123;</span><br><span class="line">        temp=L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        L=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkedStackEmpty</span><span class="params">(LinkedStack L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LinkedStack is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LinkedStack isn&#x27;t Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkedStack &amp;L,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    LinkedStack temp;</span><br><span class="line">    temp=(LinkedStackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStackNode));<span class="comment">//创建临时结点</span></span><br><span class="line">    temp-&gt;data=e;<span class="comment">//将e赋值给temp的数据域</span></span><br><span class="line">    temp-&gt;next=L-&gt;next;<span class="comment">//temp结点指向下一结点</span></span><br><span class="line">    L-&gt;next=temp;<span class="comment">//更改L结点的指向temp结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkedStack &amp;L,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    LinkedStack temp;</span><br><span class="line">    temp=L-&gt;next;</span><br><span class="line">    e=temp-&gt;data;</span><br><span class="line">    L-&gt;next=temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(LinkedStack L,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e=L-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;              <span class="comment">//记几个测试代码，可随意修改</span></span><br><span class="line">    <span class="keyword">int</span> n,i,e;</span><br><span class="line">    LinkedStackNode *top;</span><br><span class="line">    InitLinkedStack(top);</span><br><span class="line">    LinkedStackEmpty(top);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Push(top, i);</span><br><span class="line">    &#125;</span><br><span class="line">    Pop(top,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,e);</span><br><span class="line">    GetElem(top, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,e);</span><br><span class="line">    DestroyList(top);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-队列的基本概念"><a href="#3-4-队列的基本概念" class="headerlink" title="3.4 队列的基本概念"></a>3.4 队列的基本概念</h2><p>　　与栈不同的是，队列的两端都“开口”，要求数据只能,<font color="red">从一端进，从另一端出</font>。</p>
<p><img src="../../../images/数据结构/1I33AU8-0.gif" alt="1234"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常，称进数据的一端叫做“队尾”，出数据的一端叫做“队头”，添加数据叫做入队，出队列叫做出队</span><br></pre></td></tr></table></figure>
<p>队列遵循<font color="ff0000">先进先出的原则</font>，队列存储结构的实现有以下两种方式：</p>
<ul>
<li>顺序队列：在顺序表的基础上实现队列的结构</li>
<li>链队列：在链表的基础上实现队列结构</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InitQueue(&amp;Q):<span class="comment">//初始化队列</span></span><br><span class="line">DestroyQueue(&amp;Q):<span class="comment">//销毁队列</span></span><br><span class="line"></span><br><span class="line">EnQueue(&amp;Q,x);<span class="comment">//入队</span></span><br><span class="line">DeQueue(&amp;Q,&amp;x);<span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line">GetHead(Q,&amp;x);<span class="comment">//读队头元素</span></span><br></pre></td></tr></table></figure>
<p><img src="../../../images/数据结构/image-20220815181235440.png" alt="image-20220815181235440"></p>
<p><img src="../../../images/数据结构/image-20220815181450809.png" alt="image-20220815181450809"></p>
<p><img src="../../../images/数据结构/image-20220708090638224.png" alt="image-20220708090638224"></p>
<p><strong>1.队列初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.rear=<span class="number">0</span>;</span><br><span class="line">    Q.front=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果队列为空则Q.front=Q.rear</span></span><br></pre></td></tr></table></figure>
<p><strong>2.入队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    Q.data[Q.rear] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.出队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.读取队头元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取队头元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==队列元素个数：(rear+MaxSize-front)%MaxSize==</p>
<p><img src="../../../images/数据结构/image-20220708090820199.png" alt="image-20220708090820199"></p>
<p><img src="../../../images/数据结构/image-20220708090938288.png" alt="image-20220708090938288"></p>
<h3 id="3-4-1-队列的顺序存储"><a href="#3-4-1-队列的顺序存储" class="headerlink" title="3.4.1 队列的顺序存储"></a>3.4.1 队列的顺序存储</h3><p>　　为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（front 和 rear）分别用于指向顺序队列中的队头元素和队尾元素。</p>
<p>由于顺序队列初始状态没有存储任何元素，因此 <code>top</code> 指针和 <code>rear</code> 指针重合，且由于顺序队列底层实现靠的是数组，因此 <code>top</code> 和 <code>rear</code> 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p>
<p>用顺序表来存储队列元素的数据结构称为队列的顺序存储结构，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[maxsize];	<span class="comment">//定义数组</span></span><br><span class="line">    <span class="keyword">int</span> front;			<span class="comment">//队首指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;			<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;				<span class="comment">//顺序队列定义</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-队列的链式存储结构"><a href="#3-4-2-队列的链式存储结构" class="headerlink" title="3.4.2 队列的链式存储结构"></a>3.4.2 队列的链式存储结构</h3><p><img src="../../../images/数据结构/image-20220815172419389.png" alt="image-20220815172419389"></p>
<ul>
<li>链式队列的结构定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="comment">//队列的链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span> &#123;</span></span><br><span class="line">    LinkNode *front;</span><br><span class="line">    LinkNode *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p><strong>1.链队的初始化</strong></p>
<p><img src="../../../images/数据结构/image-20220711085301857.png" alt="image-20220711085301857"><img src="../../../images/数据结构/image-20220711085453549.png" alt="image-20220711085453549"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头节点,判空是Q.front==Q.rear</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化front和rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不带头结点，判空Q.front==NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化front和rear都指向NULL</span></span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.入队（带头节点）</strong></p>
<p><img src="../../../images/数据结构/image-20220711090031520.png" alt="image-20220711090031520"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s.data=x;</span><br><span class="line">    s.next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;<span class="comment">//新节点插入到rear节点之后</span></span><br><span class="line">    Q.rear=s;<span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.入队（不带头节点）</strong></p>
<p><img src="../../../images/数据结构/image-20220711090810128.png" alt="image-20220711090810128"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s.data=x;</span><br><span class="line">    s.next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//不带头结点的队列，第一个元素入队时需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front=s;</span><br><span class="line">        Q.rear=s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next=s;<span class="comment">//新节点插入到rear节点后</span></span><br><span class="line">        Q.rear=s;<span class="comment">//修改rear指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.出队（带头节点）</strong></p>
<p><img src="../../../images/数据结构/image-20220711105659430.png" alt="image-20220711105659430"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;<span class="comment">//用变量x返回队头指针</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;<span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)<span class="comment">//如果是最后一个节点</span></span><br><span class="line">        Q.rear = Q.front;<span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.出队（不带头节点）</strong></p>
<p><img src="../../../images/数据结构/image-20220711105959849.png" alt="image-20220711105959849"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点，不带头节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) &#123;</span><br><span class="line">        Q.front = <span class="literal">NULL</span>;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-3-双端队列"><a href="#3-4-3-双端队列" class="headerlink" title="3.4.3 双端队列"></a>3.4.3 双端队列</h3><p>操作受限的线性表</p>
<p><img src="../../../images/数据结构/image-20220711110533027.png" alt="image-20220711110533027"></p>
<h2 id="3-5-栈和队列的应用"><a href="#3-5-栈和队列的应用" class="headerlink" title="3.5 栈和队列的应用"></a>3.5 栈和队列的应用</h2><h3 id="3-5-1-栈的括号匹配问题"><a href="#3-5-1-栈的括号匹配问题" class="headerlink" title="3.5.1 栈的括号匹配问题"></a>3.5.1 栈的括号匹配问题</h3><blockquote>
<p>依次扫描所有字符，遇到左括号入栈，遇到有括号弹栈并检查是否匹配。</p>
<p>匹配失败的情况：①左括号单身②右括号单身③左右括号不匹配</p>
</blockquote>
<p><img src="../../../images/数据结构/image-20220711205957456.png" alt="image-20220711205957456"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    initStack(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            Push(S, str[i]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqStackEmpty(S))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> topElem;</span><br><span class="line">            Pop(S, topElem);</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-2-栈的表达式求值"><a href="#3-5-2-栈的表达式求值" class="headerlink" title="3.5.2 栈的表达式求值"></a>3.5.2 栈的表达式求值</h3><p><strong>1.三种表达式</strong></p>
<p><img src="../../../images/数据结构/image-20220711210827504.png" alt="image-20220711210827504"></p>
<p><strong>如何运算？</strong></p>
<p>前缀：右优先；后缀：左优先。</p>
<p><img src="../../../images/数据结构/image-20220711211758907.png" alt="image-20220711211758907"></p>
<p><strong>3.栈实现思路</strong></p>
<p>后缀表达式计算方法：</p>
<blockquote>
<p>①左往右扫描下一个元素，直到处理完所有操作数。</p>
<p>②若扫描到操作数则压入栈，并回到①；否则③</p>
<p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压入栈顶，回到①</p>
</blockquote>
<p>前缀表达式计算方法：</p>
<blockquote>
<p>①右往左扫描下一个元素，直到处理完所有操作数。</p>
<p>②若扫描到操作数则压入栈，并回到①；否则③</p>
<p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压入栈顶，回到①</p>
</blockquote>
<p>中缀表达式转后缀表达式：</p>
<p><img src="../../../images/数据结构/image-20220711213135231.png" alt="image-20220711213135231"></p>
<p>中缀表达式的实现：是以上两种的结合</p>
<p><img src="../../../images/数据结构/image-20220711213233762.png" alt="image-20220711213233762"></p>
<h2 id="3-6-队列的应用"><a href="#3-6-队列的应用" class="headerlink" title="3.6 队列的应用"></a>3.6 队列的应用</h2><h3 id="3-6-1-用队列实现树的层次遍历"><a href="#3-6-1-用队列实现树的层次遍历" class="headerlink" title="3.6.1 用队列实现树的层次遍历"></a>3.6.1 用队列实现树的层次遍历</h3><h3 id="3-6-2-用队列实现图的广度优先遍历"><a href="#3-6-2-用队列实现图的广度优先遍历" class="headerlink" title="3.6.2 用队列实现图的广度优先遍历"></a>3.6.2 用队列实现图的广度优先遍历</h3><h2 id="3-7-特殊矩阵的压缩存储"><a href="#3-7-特殊矩阵的压缩存储" class="headerlink" title="3.7 特殊矩阵的压缩存储"></a>3.7 特殊矩阵的压缩存储</h2><h3 id="3-7-1-数组"><a href="#3-7-1-数组" class="headerlink" title="3.7.1 数组"></a>3.7.1 数组</h3><p>一维数组：</p>
<p>a[i]的存放地址=$LOC + i * sizeof(ElemType)$     ==i默认从0开始==</p>
<p>二维数组：b[M][N]</p>
<p>行优先：b[i][j]存储地址=$LOC + (i<em>N+j)</em>sizeof(ElemType)$</p>
<p>列优先：b[i][j]存储地址=$LOC + (i+j<em>M)</em>sizeof(ElemType)$</p>
<h3 id="3-7-2-对称矩阵存储"><a href="#3-7-2-对称矩阵存储" class="headerlink" title="3.7.2 对称矩阵存储"></a>3.7.2 对称矩阵存储</h3><p>存储策略一（行优先）：</p>
<blockquote>
<p>只存主对角线+下三角区域</p>
</blockquote>
<p><img src="../../../images/数据结构/image-20220712084132483.png" alt="image-20220712084132483"></p>
<p>矩阵元素在数组中的下标k=$\begin{cases}\frac{i(i-1)}{2}+j-1,  i\ge j\{\frac{j(j-1)}{2}+i-1},i\lt j\end{cases}$</p>
<h3 id="3-7-3-三角矩阵的压缩存储"><a href="#3-7-3-三角矩阵的压缩存储" class="headerlink" title="3.7.3 三角矩阵的压缩存储"></a>3.7.3 三角矩阵的压缩存储</h3><p>存储下三角和主对角线：</p>
<p><img src="../../../images/数据结构/image-20220712085153458.png" alt="image-20220712085153458"></p>
<p>存储上三角和主对角线：</p>
<p><img src="../../../images/数据结构/image-20220712085743563.png" alt="image-20220712085743563"></p>
<h3 id="3-7-4-三对角矩阵"><a href="#3-7-4-三对角矩阵" class="headerlink" title="3.7.4 三对角矩阵"></a>3.7.4 三对角矩阵</h3><p><img src="../../../images/数据结构/image-20220712090141737.png" alt="image-20220712090141737"></p>
<p><img src="../../../images/数据结构/image-20220712090146582.png" alt="image-20220712090146582"></p>
<h3 id="3-7-5-稀疏矩阵的压缩存储"><a href="#3-7-5-稀疏矩阵的压缩存储" class="headerlink" title="3.7.5 稀疏矩阵的压缩存储"></a>3.7.5 稀疏矩阵的压缩存储</h3><p>三元组策略：</p>
<p><img src="../../../images/数据结构/image-20220712093936345.png" alt="image-20220712093936345"></p>
<p>链式存储——十字链表法</p>
<p><img src="../../../images/数据结构/image-20220712094144507.png" alt="image-20220712094144507"></p>
<h1 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h1><h2 id="4-1-串的基本概念"><a href="#4-1-串的基本概念" class="headerlink" title="4.1 串的基本概念"></a>4.1 串的基本概念</h2><p>字符串是由零个或多个字符组成的有限序列。</p>
<p>子串：串中任意个<font color="red">连续的</font>字符组成的子序列。</p>
<p>主串：包含子串的串。</p>
<h2 id="4-2-串的基本操作"><a href="#4-2-串的基本操作" class="headerlink" title="4.2 串的基本操作"></a>4.2 串的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StrAssign(&amp;T,chars);<span class="comment">//赋值</span></span><br><span class="line">StrCopy(&amp;T,S);<span class="comment">//复制串，由串S复制得到串T</span></span><br><span class="line">StrEmpty(S);<span class="comment">//判空，若S为空串，返回True，否则false</span></span><br><span class="line">StrLength(S);<span class="comment">//求串长</span></span><br><span class="line">ClearString(&amp;S);<span class="comment">//清空操作</span></span><br><span class="line">DestroyString(&amp;S);<span class="comment">//销毁串</span></span><br><span class="line">Concat(&amp;T,S1,S2);<span class="comment">//串联接。用T返回S1和S2拼接的新串</span></span><br><span class="line">SubString(&amp;Sub,S,pos,len);<span class="comment">//求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span></span><br><span class="line">Index(S,T);<span class="comment">//定位操作。若主串S中存在与串T值相同的串，则返回它在主串S的第一次出现的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-1-串的顺序存储"><a href="#4-2-1-串的顺序存储" class="headerlink" title="4.2.1 串的顺序存储"></a>4.2.1 串的顺序存储</h3><p><img src="../../../images/数据结构/image-20220712104045770.png" alt="image-20220712104045770"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SString</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HString</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HString S;</span><br><span class="line">S.ch=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MAXLEN * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-串的链式存储"><a href="#4-2-2-串的链式存储" class="headerlink" title="4.2.2 串的链式存储"></a>4.2.2 串的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;<span class="comment">//每个节点存1个字符</span></span><br><span class="line">    StringNode *next;</span><br><span class="line">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/数据结构/image-20220712111109308.png" alt="image-20220712111109308"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">4</span>];<span class="comment">//每个节点存多个个字符</span></span><br><span class="line">    StringNode *next;</span><br><span class="line">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/数据结构/image-20220712111118458.png" alt="image-20220712111118458"></p>
<p><strong>链式存储基本操作实现</strong></p>
<p>求子串：</p>
<p><img src="../../../images/数据结构/image-20220712104336797.png" alt="image-20220712104336797"></p>
<p>比较串：</p>
<p><img src="../../../images/数据结构/image-20220712105008432.png" alt="image-20220712105008432"></p>
<p>求位置：</p>
<p><img src="../../../images/数据结构/image-20220712105738017.png" alt="image-20220712105738017"></p>
<h2 id="4-3-字符串的模式匹配"><a href="#4-3-字符串的模式匹配" class="headerlink" title="4.3 字符串的模式匹配"></a>4.3 字符串的模式匹配</h2><h3 id="4-3-1-暴力循环"><a href="#4-3-1-暴力循环" class="headerlink" title="4.3.1 暴力循环"></a>4.3.1 暴力循环</h3><blockquote>
<p>将主串中<font color="red">所有长度为m的子串</font>(最多n-m+1个)依次与模式串进行对比，直到找到一个完全匹配的子串或所有子串不匹配。</p>
</blockquote>
<p><img src="../../../images/数据结构/image-20220712110532903.png" alt="image-20220712110532903"></p>
<p><img src="../../../images/数据结构/image-20220712111433819.png" alt="image-20220712111433819"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SString</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; StringNode, *String;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">violent</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏时间复杂度：O(mn)</p>
<h3 id="4-3-2-KMP算法"><a href="#4-3-2-KMP算法" class="headerlink" title="4.3.2 KMP算法"></a>4.3.2 KMP算法</h3><p><img src="../../../images/数据结构/image-20220712151124937.png" alt="image-20220712151124937"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(SString S, SString T,<span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j=<span class="number">0</span>||S.ch[i] == T.ch[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏情况：O(m+n)</p>
<p><strong>求next数组：</strong></p>
<p>next数组作用：当模式串的第j个字符失配时，从模式串的第next[j]个继续往后匹配</p>
<p>==任何模式串的next[1]=0;next[2]=1==</p>
<p>模式串T=ababaa</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>next[0]</th>
<th>next[1]</th>
<th>next[2]</th>
<th>next[3]</th>
<th>next[4]</th>
<th>next[5]</th>
<th>next[6]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p><img src="../../../images/数据结构/SmartSelect_20220911-171036_Samsung Notes.jpg" alt="SmartSelect_20220911-171036_Samsung Notes" style="zoom:50%;" /></p>
<h3 id="4-3-3-KMP优化"><a href="#4-3-3-KMP优化" class="headerlink" title="4.3.3 KMP优化"></a>4.3.3 KMP优化</h3><p>nextval数组：</p>
<p>next[1]直接写0</p>
<p><img src="../../../images/数据结构/image-20220712200914670.png" alt="image-20220712200914670"></p>
<h1 id="第五章-树和二叉树"><a href="#第五章-树和二叉树" class="headerlink" title="第五章 树和二叉树"></a>第五章 树和二叉树</h1><h2 id="5-1-树"><a href="#5-1-树" class="headerlink" title="5.1 树"></a>5.1 树</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><p>　　树是n(n&gt;=0)个结点的有限集，它或为空树(n=0)；或为非空树，对于非空树T：</p>
<p>（1）有且仅有一个称之为根的结点；</p>
<p>（2）除根节点意外的其余结点可分为m（m&gt;0）个互不相交的有限集T<sub>1</sub>，T<sub>2</sub>，…，T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树。</p>
<p><img src="../../../images/数据结构/1617786835-image-20210407171355733.png" alt="image-20210407171355733" style="zoom:67%;" /></p>
<h3 id="5-1-2-树的基本术语"><a href="#5-1-2-树的基本术语" class="headerlink" title="5.1.2 树的基本术语"></a>5.1.2 树的基本术语</h3><p>如图5.1（b）：</p>
<p>　　（1）<strong>结点</strong>：数中的一个独立单元。包含一个数据元素及若干指向其子树的分支，如图的A、B、C、D等。</p>
<p>　　（2）<strong>结点的度</strong>：结点拥有的子树数。如，A的度是3，C的度是1，F的度是0。</p>
<p>　　（3）<strong>树的度</strong>：树内各结点度的最大值</p>
<p>　　（4）<strong>叶子</strong>：度为0的结点称为<strong>叶子或终端结点</strong>。比如，K、L、F、G、M、I、J都是树的叶子。</p>
<p>　　（5）<strong>非终端结点</strong>：度不为0<strong>的结点称为非终端结点或分支节点</strong>。除根结点之外，也叫内部节点。</p>
<p>　　（6）<strong>双亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。如，B的双亲为A，B的孩子有E和Ｆ。</p>
<p>　　（７）<strong>层次</strong>：结点的层次从根开始定义，根为第一层，根的孩子为第二层等等。</p>
<p>　　（8）<strong>树的深度</strong>：树中结点的最大层次称为树的深度或高度，上图树的深度为4。</p>
<p><strong>常用性质：</strong></p>
<p>①结点数=总度数+1</p>
<p>②度为m的树、m叉树的区别</p>
<p><img src="../../../images/数据结构/image-20220712202935008.png" alt="image-20220712202935008"></p>
<p>③度为m的树第i层至多有$m^{i-1}$个节点$(i\ge1)$</p>
<p><img src="../../../images/数据结构/image-20220712203210512.png" alt="image-20220712203210512"></p>
<p>④高度为h的m叉树至多有$\frac{m^{h}-1}{m-1}$个结点</p>
<blockquote>
<p>将③的每层相加，是等比数列求和</p>
</blockquote>
<p>⑤高度为h的m叉树至少有h个结点</p>
<p>高度为h、度为m的树至少有h+m-1个结点</p>
<p><img src="../../../images/数据结构/image-20220712203822313.png" alt="image-20220712203822313"></p>
<p>⑥具有n个结点的m叉树的最小高度为$\left\lceil{log_m(n(m-1)+1)}\right \rceil$——所有结点都有m个孩子</p>
<script type="math/tex; mode=display">
\frac{m^{h-1}-1}{m-1}\lt n \le \frac{m^{h}-1}{m-1}\\
{m^{h-1}-1}\lt n(m-1) \le {m^{h}-1}\\
m^{h-1}\lt n(m-1)+1 \le m^{h}\\
取对数：h-1<log_m{(n(m-1)+1)\le h}</script><h2 id="5-2-二叉树"><a href="#5-2-二叉树" class="headerlink" title="5.2 二叉树"></a>5.2 二叉树</h2><h3 id="5-2-1-二叉树的定义"><a href="#5-2-1-二叉树的定义" class="headerlink" title="5.2.1 二叉树的定义"></a>5.2.1 二叉树的定义</h3><p>==n个结点，组成二叉树的个数为：$\frac{1}{n+1}C{^n_{2n}}=\frac{1}{n+1}\frac{(2n)!}{n!+n!}$==</p>
<p>　　二叉树（Binary Tree）是n(n&gt;=0)个结点所构成的集合，它或为空树(n=0)；或为非空树，对于非空树T：</p>
<p>（1）有且仅有一个称之为根的结点；</p>
<p>（2）除根结点之外的其余结点分为两个互不相交的子集T<sub>1</sub>和T<sub>2</sub>，分别称为T的左子树和右子树，且T<sub>1</sub>和T<sub>2</sub>本身又都是二叉树。</p>
<p><strong>二叉树的基本特点</strong></p>
<ul>
<li>结点的度都&lt;=2</li>
<li>有序树（子树有序，不能颠倒）</li>
</ul>
<p><img src="../../../images/数据结构/1617844641-image-20210408091721508.png" alt="image-20210408091721508" style="zoom:67%;" /></p>
<h3 id="5-2-2-二叉树的性质"><a href="#5-2-2-二叉树的性质" class="headerlink" title="5.2.2 二叉树的性质"></a>5.2.2 二叉树的性质</h3><p><strong>性质1</strong> 在二叉树的第i层上至多有2<sup>i-1</sup>个节点（i&gt;=1）。</p>
<p><img src="../../../images/数据结构/1617876251-image-20210408180411607.png" alt="image-20210408180411607" style="zoom:67%;" /></p>
<p><strong>性质2</strong> 深度为k的二叉树至多有2<sup>k</sup>-1个节点（满二叉树）（k&gt;=1）。</p>
<p><img src="../../../images/数据结构/1617876268-image-20210408180428251.png" alt="image-20210408180428251" style="zoom:67%;" /></p>
<p><strong>性质3</strong> 对任何一个二叉树T，如果度为0、1、2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>、n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</p>
<script type="math/tex; mode=display">
假设树中结点总数为n，则\\
\begin{cases}
n=n_0+n_1+n_2\\
n=n_1+2n_2+1
\end{cases}\\
因此：n_0=n_2+1</script><p><strong>性质4</strong> 具有n个结点的完全二叉树的高度为：$\left \lfloor \log_2n\right \rfloor+1$</p>
<blockquote>
<script type="math/tex; mode=display">
\left \lfloor x\right \rfloor取不大于x的最大整数，\left \lceil x \right \rceil取不小于x的最小整数。</script></blockquote>
<p><strong>性质5</strong> 如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到第[log<sub>2</sub>n]+1层，每层从左到右),则对任一结点i（1&lt;=i&lt;=n),有：</p>
<p>（1）如果i＝1，则结点i无双亲，是二叉树的根；如果i&gt;1，则其双亲是结点[i/2]。</p>
<p> （2）如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；若2i==n，其左孩子是结点2i（i为最后一个非叶子结点）。</p>
<p> （3）如果2i＋1&gt;n，则结点i无右孩子；若2i＋1==n ，其右孩子是结点2i＋1（i为最后一个非叶子结点）。</p>
<h3 id="5-2-3-特殊的二叉树"><a href="#5-2-3-特殊的二叉树" class="headerlink" title="5.2.3 特殊的二叉树"></a>5.2.3 特殊的二叉树</h3><p><strong>（1）满二叉树：</strong>一个深度为h且有2<sup>h</sup>-1个结点的二叉树。</p>
<p><img src="../../../images/数据结构/1617876532-image-20210408180852817.png" alt="image-20210408180852817" style="zoom: 80%;" /></p>
<p>特点：</p>
<blockquote>
<p>①只有最后一层有叶子结点</p>
<p>②不存在度为1的节点</p>
<p>③按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，父节点为i/2</p>
</blockquote>
<p><strong>（2）完全二叉树：</strong>高度为h的，有n个节点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号从1至n的结点一一对应（且最后一层叶子不满，全部集中在左边）</p>
<p><img src="../../../images/数据结构/1617876541-image-20210408180901861.png" alt="image-20210408180901861" style="zoom: 80%;" /></p>
<p>特点：</p>
<blockquote>
<p>①只有最后两层可能有叶子结点</p>
<p>②最多只有一个度为1的节点($n_0只能等于0或1$)</p>
<p>③按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，父节点为i/2</p>
<p>④$i \le \frac{n}{2}$为分支节点，$i &gt; \frac{n}{2}$为叶子结点</p>
</blockquote>
<p><strong>（3）二叉排序树</strong>：一颗二叉树或者是空二叉树，或者是如下性质的二叉树：</p>
<blockquote>
<p>①左子树上所有结点的关键字均小于根节点</p>
<p>②右子树上所有结点的关键字均大于根节点</p>
<p>③左、右子树又各是一颗二叉排序树</p>
</blockquote>
<p><img src="../../../images/数据结构/image-20220712210501560.png" alt="image-20220712210501560"></p>
<p><strong>（4）平衡二叉树</strong>：树上任一结点的左子树和右子树的高度只差不超过1</p>
<h3 id="5-2-4-二叉树的存储结构"><a href="#5-2-4-二叉树的存储结构" class="headerlink" title="5.2.4 二叉树的存储结构"></a>5.2.4 二叉树的存储结构</h3><p><strong>1 顺序存储结构</strong></p>
<p>==顺序存储只适合完全二叉树==</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;</span><br><span class="line">    <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeNode t[MaxSize]：</p>
<p>定义一个长度为MaxSize的数组t，按照从上到下、从左到右的顺序依次存储完全二叉树的各个结点</p>
<p><img src="../../../images/数据结构/image-20220701221609629.png" alt="image-20220701221609629"></p>
<p><img src="../../../images/数据结构/image-20220714095417721.png" alt="image-20220714095417721"></p>
<p><strong>2 链式存储结构</strong></p>
<p><img src="../../../images/数据结构/1617786182-image-20210407170302561.png" alt="image-20210407170302561"></p>
<p>如图 1 所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，图 1 对应的链式存储结构如图 2 所示：</p>
<p><img src="../../../images/数据结构/1617786227-image-20210407170347593.png" alt="image-20210407170347593"></p>
<p>由图 2 可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：</p>
<ul>
<li>指向左孩子节点的指针（Lchild）；</li>
<li>节点存储的数据（data）；</li>
<li>指向右孩子节点的指针（Rchild）；</li>
</ul>
<p><img src="../../../images/数据结构/1617786252-image-20210407170412791.png" alt="image-20210407170412791"></p>
<p>表示该节点结构的 C 语言代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span>  </span><br><span class="line">    TElemType data;<span class="comment">//数据域   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span><span class="comment">//可以有可以没有</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-遍历二叉树"><a href="#5-3-遍历二叉树" class="headerlink" title="5.3 遍历二叉树"></a>5.3 遍历二叉树</h2><p>二叉树由3个基本单元组成：根结点、左子树、右子树。因此可以分为三个遍历部分。可以参考具体<a target="_blank" rel="noopener" href="https://www.pianshen.com/article/7106254596/">链接</a>。</p>
<ul>
<li><p>DLR——先序遍历，根左右</p>
</li>
<li><p>LDR——中序遍历，左根右</p>
</li>
<li><p>LRD——后序遍历，左右根</p>
</li>
</ul>
<p><img src="../../../images/数据结构/1617788435-image-20210407174035666.png" alt="image-20210407174035666"></p>
<h3 id="5-3-1-先序遍历"><a href="#5-3-1-先序遍历" class="headerlink" title="5.3.1 先序遍历"></a>5.3.1 先序遍历</h3><blockquote>
<p>先序遍历：访问根节点，访问当前节点的左子树；若当前节点无左子树，则访问当前节点的右子树。O(h)</p>
</blockquote>
<p><img src="../../../images/数据结构/1619053575-image-20210422090614930.png" alt="image-20210422090614930"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-中序遍历"><a href="#5-3-2-中序遍历" class="headerlink" title="5.3.2 中序遍历"></a>5.3.2 中序遍历</h3><blockquote>
<p>中序遍历：访问当前节点的左子树；访问根节点；访问当前节点的右子树。</p>
</blockquote>
<p><img src="../../../images/数据结构/1619053611-image-20210422090651292.png" alt="image-20210422090651292"></p>
<p><strong>中序遍历的递归算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        Inorder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>中序遍历的非递归算法</strong></p>
<p>①初始化一个空栈S，指针p指向根结点</p>
<p>②申请一个结点空间q，用来存放栈顶弹出的元素</p>
<p>③当p非空或者栈S非空时，循环执行以下操作：</p>
<ul>
<li>如果p非空，则将p进栈，p指向该结点的左孩子；</li>
<li>如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    p=T;</span><br><span class="line">    q=<span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span>(p||!StackEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;<span class="comment">//p非空</span></span><br><span class="line">            Push(S,p);<span class="comment">//根指针进栈</span></span><br><span class="line">            p=p-&gt;lchild;<span class="comment">//根指针进栈，遍历左子树 </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//p空</span></span><br><span class="line">            Pop(S,q);<span class="comment">//退栈</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;q-&gt;data;<span class="comment">//访问根结点</span></span><br><span class="line">            p=q-&gt;rchild;<span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-后序遍历"><a href="#5-3-3-后序遍历" class="headerlink" title="5.3.3 后序遍历"></a>5.3.3 后序遍历</h3><blockquote>
<p>后序遍历：从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。</p>
</blockquote>
<p><img src="../../../images/数据结构/1619053789-image-20210422090949365.png" alt="image-20210422090949365"></p>
<h3 id="5-3-4-层序遍历"><a href="#5-3-4-层序遍历" class="headerlink" title="5.3.4 层序遍历"></a>5.3.4 层序遍历</h3><blockquote>
<p>层次遍历：从上往下一层一层遍历。</p>
<p>算法思想：</p>
<p>①初始化一个辅助队列</p>
<p>②根节点入队</p>
<p>③队列非空，则队头结点出队，访问该节点，并将其左右孩子插入队尾</p>
<p>④重复③直至队列为空</p>
</blockquote>
<p><img src="../../../images/数据结构/1619053809-image-20210422091009192.png" alt="image-20210422091009192"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    BiTNode *lchirld,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode *data;</span><br><span class="line">    LinkNode *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);<span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);<span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;<span class="comment">//队列不空则循环</span></span><br><span class="line">        DeQueue(Q,p);<span class="comment">//队头结点出队</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);<span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);<span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-5-二叉树的遍历应用"><a href="#5-3-5-二叉树的遍历应用" class="headerlink" title="5.3.5 二叉树的遍历应用"></a>5.3.5 二叉树的遍历应用</h3><ul>
<li><strong>由遍历序列构造二叉树</strong></li>
</ul>
<p>前序序列：ADBCE</p>
<p>中序序列：BDCAE</p>
<hr>
<p>后序序列：EFAHCIGBD</p>
<p>中序序列：EAFDHCBGI</p>
<hr>
<p>层序序列：DABEFCGHI</p>
<p>中序序列：EAFDHCBGI</p>
<ul>
<li><strong>先序遍历的顺序建立二叉链表</strong></li>
</ul>
<blockquote>
<p>1.扫描序列，读入字符ch。</p>
<p>2.如果ch是一个“#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：</p>
<p>①申请一个节点空间T；</p>
<p>②将ch赋给T-&gt;data;</p>
<p>③递归创建T的左子树；</p>
<p>④递归创建T的右子树；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//按先序次序输入二叉树中的结点的值，创建二叉链表表示二叉树T</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>; <span class="comment">//递归结束，建立空树</span></span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//递归创建二叉树</span></span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;<span class="comment">//生成根节点</span></span><br><span class="line">        T-&gt;data=ch;<span class="comment">//根结点数据域为ch</span></span><br><span class="line">        CreateBiTree(T-&gt;lchild);<span class="comment">//递归创建左子树</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild);<span class="comment">//递归创建右子树</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>复制二叉树</strong></li>
</ul>
<blockquote>
<p>①若二叉树不空，则首先复制根结点（相当于先序遍历算法中访问根节点的语句）</p>
<p>②然后分别复制二叉树根结点的左子树和右子树（相当于先序遍历中递归遍历左子树和右子树的语句）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        NewT=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>计算二叉树深度</strong></li>
</ul>
<blockquote>
<p>如果是空树，递归结束，深度为0，否则</p>
<ul>
<li>递归计算左子树的深度为m；</li>
<li>递归计算右子树的深度为n；</li>
<li>如果m&gt;n，二叉树的深度为m+1，否则n+1。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//计算二叉树T的深度</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果是空树，深度为0, 递归结束</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=Depth(T-&gt;lchild);<span class="comment">//递归计算左子树的深度记为m</span></span><br><span class="line">        <span class="keyword">int</span> n=Depth(T-&gt;rchild);<span class="comment">//递归计算右子树的深度记为n</span></span><br><span class="line">        <span class="keyword">return</span> m&gt;n ? m+<span class="number">1</span> : n+<span class="number">1</span>;<span class="comment">//二叉树的深度为m与n的较大者加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                             </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>统计二叉树中结点的个数</strong></li>
</ul>
<blockquote>
<p>如果是空树，则结点个数为0,；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上 1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//统计二叉树T中结点的个数</span></span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果是空树，则结点个数为0, 递归结束</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;T-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + <span class="number">1</span>;<span class="comment">//否则结点个数为左子树的结点个数＋右子树的结点个数+l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>计算二叉树叶子结点的数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeadCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) 	<span class="comment">//如果是空树返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果是叶子结点返回1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> LeafCount(T-&gt;lchild) + LeafCount(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="ff000">在n个结点的二叉链表中，有n+1个空指针域</font>

<p>二叉链表长这个样子：</p>
<p><img src="../../../images/数据结构/2012031419192993.png" alt="img"></p>
<h2 id="5-4-线索二叉树"><a href="#5-4-线索二叉树" class="headerlink" title="5.4 线索二叉树"></a>5.4 线索二叉树</h2><font color="red">是为了解决找前驱和后继不方便：</font>

<p><img src="../../../images/数据结构/image-20220713093134719.png" alt="image-20220713093134719"></p>
<p>==n个结点的二叉树有n+1个空链域==</p>
<p>​        遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。若将某种遍历序列某个结点的前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树。</p>
<p>如何保存这类信息？</p>
<script type="math/tex; mode=display">
两种解决方法=\begin{cases}
增加两个域：fwd和bwd;　　　使得结构的存储密度大大降低\\
\\
利用空链域（n+1个空链域）　　　　　　　　　　
\end{cases}</script><p>所以基于某种遍历规则：<br>1）若结点有左子树，则lchild指向其左孩子；<br>       否则， lchild指向其直接前驱(即线索)；</p>
<p>2）若结点有右子树，则rchild指向其右孩子；<br>       否则， rchild指向其直接后继(即线索) 。</p>
<font color ="#0000ff">为了避免混淆，增加两个标志域</font>

<p><img src="../../../images/数据结构/1618393158-image-20210414173918248.png" alt="image-20210414173918248"></p>
<p>其中：</p>
<script type="math/tex; mode=display">
LTag=\begin{cases}
0　lchild域指示结点的左孩子　\\
1　lchild域指示结点的前驱　　　　　　　　　　
\end{cases}</script><script type="math/tex; mode=display">
RTag=\begin{cases}
0　lchild域指示结点的左孩子　\\
1　lchild域指示结点的后继　　　　　　　　　　
\end{cases}</script><p>二叉树二叉线索类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> LTag,RTag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/数据结构/image-20220713093936717.png" alt="image-20220713093936717"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">中序线索化</th>
<th style="text-align:center">先序线索化</th>
<th style="text-align:center">后序线索化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">找前驱</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">找后继</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-4-1-中序线索化"><a href="#5-4-1-中序线索化" class="headerlink" title="5.4.1 中序线索化"></a>5.4.1 中序线索化</h3><p><img src="../../../images/数据结构/image-20220714090240972.png" alt="image-20220714090240972"></p>
<p><img src="../../../images/数据结构/image-20220714090517756.png" alt="image-20220714090517756"></p>
<h3 id="5-4-2-先序线索化"><a href="#5-4-2-先序线索化" class="headerlink" title="5.4.2 先序线索化"></a>5.4.2 先序线索化</h3><p>找前驱：根据遍历规则（NLR），<strong>结点只可能是根的后继</strong></p>
<p>二叉链表变三叉链表，就可以找：</p>
<p><img src="../../../images/数据结构/image-20220714091725908.png" alt="image-20220714091725908"></p>
<p>找后继：</p>
<p><img src="../../../images/数据结构/image-20220714091520838.png" alt="image-20220714091520838"></p>
<h3 id="5-5-3-后序线索化"><a href="#5-5-3-后序线索化" class="headerlink" title="5.5.3 后序线索化"></a>5.5.3 后序线索化</h3><p>找前驱：</p>
<p><img src="../../../images/数据结构/image-20220714091431926.png" alt="image-20220714091431926"></p>
<p>找后继：根据结点遍历规则(LRN)，<strong>结点只能是前驱元素</strong>；</p>
<p><img src="../../../images/数据结构/image-20220714092026037.png" alt="image-20220714092026037"></p>
<h2 id="5-5-森林与树"><a href="#5-5-森林与树" class="headerlink" title="5.5 森林与树"></a>5.5 森林与树</h2><h3 id="5-5-1-树的存储结构"><a href="#5-5-1-树的存储结构" class="headerlink" title="5.5.1 树的存储结构"></a>5.5.1 树的存储结构</h3><p><strong>1.双亲表示法（顺序存储）</strong>：以一组连续空间存储树的结点，每个结点中保存指向双亲的“指针”。</p>
<p>根结点固定存储在0，-1表示没有双亲</p>
<p><img src="../../../images/数据结构/1618445484-image-20210415081124676.png" alt="image-20210415081124676" style="zoom:67%;" /></p>
<p>双亲实现树定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100   <span class="comment">//最大结点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span>          <span class="comment">//树结点定义</span></span><br><span class="line">    ElemType data;                 </span><br><span class="line">    <span class="keyword">int</span> parent;                        </span><br><span class="line">&#125; PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span>          <span class="comment">//树定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];                 </span><br><span class="line">    <span class="keyword">int</span> n;        <span class="comment">//结点数                       </span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>
<p><strong>删除元素：</strong></p>
<p>方案一：将<code>p-&gt;parent</code>直接改为-1，这样会导致有一条空数据，遍历查询的时候效率低</p>
<p>方案二：将最后一条数据移到该删除位</p>
<p><strong>2.孩子表示法</strong>：</p>
<p>（1）多重链表法（两种）</p>
<p>（2）孩子链表法（顺序+链式）：将每个结点的孩子结点排列起来，看成一个线性表，且以单链表作存储结构，n个结点有n个孩子链表，n个头指针组成线性表。</p>
<p><img src="../../../images/数据结构/1618445972-image-20210415081932478.png" alt="image-20210415081932478" style="zoom:67%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    CTNode *next;<span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTBox</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    CTNode *firstChild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTree</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;<span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.孩子兄弟表示法（链式存储）</strong>：每个节点除值域外，还包括两个指针，分别指向该节点的第一个孩子和下一个兄弟。</p>
<p>结点结构：<img src="../../../images/数据结构/1618446095-image-20210415082134980.png" alt="image-20210415082134980"></p>
<p><img src="../../../images/数据结构/1618446122-image-20210415082202662.png" alt="image-20210415082202662" style="zoom:67%;" /></p>
<p>结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span><span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125; CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-2-森林和二叉树的转换"><a href="#5-5-2-森林和二叉树的转换" class="headerlink" title="5.5.2 森林和二叉树的转换"></a>5.5.2 森林和二叉树的转换</h3><p><strong>1.树—-&gt;二叉树</strong></p>
<blockquote>
<p>方法（树的孩子兄弟表示法）：</p>
<p>①加线：树中所有相邻兄弟间加一连线；<br>②抹线：对树中的每个结点，只保留其与第一个孩子间的连线，删去它与其他孩子间连线；<br>③旋转：以树根为轴心，将整棵树顺时针旋转45度，使之结构层次分明。 </p>
</blockquote>
<p>　　<font color="ff000">任何一棵树和树对应的二叉树，其根结点的右子树必空。</font></p>
<p>示例：</p>
<p><img src="../../../images/数据结构/1619055375-image-20210422093615176.png" alt="image-20210422093615176"></p>
<p>特点：</p>
<ul>
<li>左分支——-父子关系   右分支—-兄弟关系</li>
<li>根没有兄弟，所以一棵树转换后的二叉树一定==只有左子树==</li>
</ul>
<p><strong>2.二叉树—-&gt;树</strong></p>
<p>①若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；</p>
<p>②删除原二叉树中所有结点与其右孩子结点的连线；</p>
<p>③整理（1）和（2）两步得到的树，使之结构层次分明。</p>
<p><img src="../../../images/数据结构/20210603-image-20210603093907428.png" alt="image-20210603093907428" style="zoom:67%;" /></p>
<p><strong>3.森林—-&gt;二叉树</strong></p>
<p>方法：</p>
<p>①将森林中每棵树转换成相应的二叉树；<br>②第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连起来后，此时，所得二叉树即是森林转换得到的。</p>
<p>示例：</p>
<p><img src="../../../images/数据结构/20210603-image-20210603095305745.png" alt="image-20210603095305745" style="zoom:67%;" /></p>
<p><strong>4.二叉树—-&gt;森林</strong></p>
<p>①先把每个结点与右孩子结点的连线删除，得到分离的二叉树；</p>
<p>②把分离后的每棵二叉树转换为树；</p>
<p>③整理第（2）步得到的树，使之规范，这样得到森林。</p>
<p>特点：根没有右孩子，则转换成的是树，否则转换成的是森林。</p>
<h3 id="5-5-3-森林和树的遍历"><a href="#5-5-3-森林和树的遍历" class="headerlink" title="5.5.3 森林和树的遍历"></a>5.5.3 森林和树的遍历</h3><p><strong>1.树的遍历</strong></p>
<ul>
<li>先根遍历：若树不空，则先访问根结点，然后依次从左到右先根遍历根的各棵子树。与对应二叉树先序序列相同。</li>
<li>后根遍历：若树不空，则先依次从左到右后根遍历根的<br>各棵子树，然后访问根结点； 与对应二叉树中序遍历相同。</li>
<li>层次遍历（用队列实现）：①若树非空，根节点入队；②队列非空，队头元素出队并访问，同时该元素的孩子依次入队；③重复②直到队列为空</li>
</ul>
<p><strong>2.森林的遍历</strong></p>
<ul>
<li>先序遍历森林：</li>
</ul>
<p>若森林非空，则可按下述规则遍历：</p>
<p>①访问森林中第一棵树的根结点；</p>
<p>②先序遍历第一棵树的根结点的子树森林；</p>
<p>③先序遍历除去第一棵树之后剩余的树构成的森林。</p>
<ul>
<li>中序遍历森林</li>
</ul>
<p>若森林非空，则可按下述规则遍历：</p>
<p>①中序遍历森林中第一棵树的根结点的子树森林；</p>
<p>②访问第一棵树的根结点；</p>
<p>③中序遍历除去第一棵树之后剩余的树构成的森林。</p>
<h2 id="5-6-哈夫曼树及其应用"><a href="#5-6-哈夫曼树及其应用" class="headerlink" title="5.6 哈夫曼树及其应用"></a>5.6 哈夫曼树及其应用</h2><h3 id="5-6-1-哈夫曼树的基本概念"><a href="#5-6-1-哈夫曼树的基本概念" class="headerlink" title="5.6.1 哈夫曼树的基本概念"></a>5.6.1 哈夫曼树的基本概念</h3><p>前缀码：在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。</p>
<p>　　哈夫曼树又称最优树，是一类带权路径长度最短的树。</p>
<p>（1）<strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</p>
<p>（2）<strong>路径长度</strong>：路径上的分支数目称作路径长度。</p>
<p>（3）<strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。</p>
<p>（4）<strong>权</strong>：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类， 所以对应有结点权和边权。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。</p>
<p>（5）<strong>结点的带权路径长度</strong>：从该结点到树根之间的路径长度与结点上权的乘积。</p>
<p>（6）<strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和，通常记作$WPL=\sum_{k=1}^{n}{w_k}{l_k}$</p>
<p>（7）<strong>哈夫曼树</strong>：假设有m个权值{$w_1,w_2,···,w_m$}，可以构造一颗含有n个叶子结点的二叉树，每个叶子结点的权为$w_i$，则其中带权路径长度WPL最小的二叉树称作最优二叉树或哈夫曼树。</p>
<h3 id="5-6-2-哈夫曼树的构造算法"><a href="#5-6-2-哈夫曼树的构造算法" class="headerlink" title="5.6.2 哈夫曼树的构造算法"></a>5.6.2 哈夫曼树的构造算法</h3><p><strong>1.哈夫曼树的构造过程</strong></p>
<p><strong>2.哈夫曼算法的实现</strong></p>
<p>由于哈夫曼树中没有度为1的结点，则一颗有n个叶子结点的哈夫曼树共有2n-1个结点。</p>
<p>哈夫曼树的存储表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;					<span class="comment">//结点的权值</span></span><br><span class="line">    <span class="keyword">int</span> parent,lchild,rchild;	<span class="comment">//结点的双亲、左孩子、右孩子</span></span><br><span class="line">&#125;*HuffmanTree;					<span class="comment">//动态分配数组存储哈夫曼树</span></span><br></pre></td></tr></table></figure>
<p><font color="ff000">为了实现方便，数组0号单元不使用，从1号单元开始使用，所以数组大小为2n</font>。叶子结点存储在前面部分1~n个位置，后面的n-1个位置存储其余非叶子结点。</p>
<p>构造哈夫曼树算法实现可以分为两部分：</p>
<p>①初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0,；最后循环n次，输入前n个单元中叶子结点的权值。</p>
<p>②创建树：循环n-1次，通过n01次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为0且权值最小的两个树根节点s1和s2；删除是指将结点s1和s2的双亲改为非0；合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个节点做孩子的下标为s1，右孩子的下标为s2。</p>
<h1 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h1><h2 id="6-1-图的定义和基本术语"><a href="#6-1-图的定义和基本术语" class="headerlink" title="6.1 图的定义和基本术语"></a>6.1 图的定义和基本术语</h2><h3 id="6-1-1-图的定义"><a href="#6-1-1-图的定义" class="headerlink" title="6.1.1 图的定义"></a>6.1.1 图的定义</h3><p>　　图由两个集合V(Vertex顶点集)和E(Edge边集)组成，记为G=(V,E)，其中V是顶点的有==穷非空==集合，E是V中顶点偶对的==有穷集合==，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合。</p>
<p>　　无向图：每条边都没有方向</p>
<p><img src="../../../images/数据结构/1618999001-image-20210421175641281.png" alt="image-20210421175641281"></p>
<p>　　有向图：每条边都有方向</p>
<p><img src="../../../images/数据结构/1618998974-image-20210421175614149.png" alt="image-20210421175614149"></p>
<p>　　完全图：任意两点都有一条边相连</p>
<div><img src="../../../images/数据结构/1618999143-image-20210421175903730.png" width="300"/> <img src="../../../images/数据结构/1618999151-image-20210421175911065-165718535507438.png" width="300"/></div>

<h3 id="6-1-2-图的基本术语"><a href="#6-1-2-图的基本术语" class="headerlink" title="6.1.2 图的基本术语"></a>6.1.2 图的基本术语</h3><p>无向图：度之和是2e</p>
<p>有向图：出度=入度=e</p>
<p><strong>顶点的度：</strong>与该顶点相关联的边的数目，记为TD(v)。</p>
<p>　　在有向图中，顶点的度等于该顶点的入度与出度之和。</p>
<p>　　顶点v的<strong>入度是以v为终点</strong>的有向边的条数，记做ID(v)，</p>
<p>　　顶点v的<strong>出度是以v为始点</strong>的有向边的条数，记做OD(v)</p>
<ul>
<li>问：当有向图仅有1个顶点的入度为0，其余顶点的入度均为1，此时是何结构？</li>
<li>答：是一棵树；一颗有向树。</li>
</ul>
<p><strong>路径：</strong>连续的边构成的顶点序列。</p>
<p><strong>路径长度：</strong>路径上边或弧的数目/权值之和。</p>
<p><strong>回路(环)：</strong>第一个顶点和最后一个顶点相同的路径。</p>
<p><strong>简单路径：</strong>路径中各顶点均不重复出现的路径。</p>
<p><strong>简单回路(简单环)：</strong>除路径起点和终点相同外，其余顶点均不重复出现的路径。</p>
<p><img src="../../../images/数据结构/1619599276-image-20210428164116694.png" alt="image-20210428164116694"></p>
<hr>
<p><strong>连通图（强连通图）：</strong>在无向图中，任意两个顶点都是连通的。在有向图中，任何一对顶点都是强连通的，则是强连通图。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>无向图</th>
<th>有向图</th>
</tr>
</thead>
<tbody>
<tr>
<td>连通图（强连通图）</td>
<td>至少n-1条边</td>
<td>至少n条边</td>
</tr>
<tr>
<td>非连通图</td>
<td>最多$C{^n_{n-1}}$条边</td>
</tr>
</tbody>
</table>
</div>
<p><img src="../../../images/数据结构/1619599384-image-20210428164304480.png" alt="image-20210428164304480"></p>
<p><strong>连通分量：</strong>无向图G 的极大连通子图称为G的连通分量。极大连通子图意思是：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。</p>
<p><img src="../../../images/数据结构/1619599429-image-20210428164349664.png" alt="image-20210428164349664"></p>
<p><strong>强连通分量：</strong>有向图G 的极大强连通子图称为G的强连通分量。极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。</p>
<p><img src="../../../images/数据结构/1619599481-image-20210428164441752.png" alt="image-20210428164441752"></p>
<p><strong>子图：</strong>设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1 V，E1 E，则称 G1是G的子图。例:(b)、(c) 是 (a) 的子图</p>
<p><img src="../../../images/数据结构/1619599589-image-20210428164628941.png" alt="image-20210428164628941"></p>
<p><strong>极小连通子图：</strong>该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。（n-1条边）</p>
<p><strong>生成树：</strong>包含无向图G 所有顶点的极小连通子图。</p>
<p>n个顶点的树，必有n-1条边</p>
<p><strong>生成森林：</strong>对非连通图，各个连通分量的生成树构成的集合。  </p>
<p><img src="../../../images/数据结构/1619599660-image-20210428164740239.png" alt="image-20210428164740239"></p>
<h2 id="6-2-图的存储结构"><a href="#6-2-图的存储结构" class="headerlink" title="6.2 图的存储结构"></a>6.2 图的存储结构</h2><p>　　图没有顺序存储结构，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。另一方面，图的链式存储有==邻接表==、==十字链表==和==邻接多重表==。</p>
<h3 id="6-2-1-邻接矩阵法"><a href="#6-2-1-邻接矩阵法" class="headerlink" title="6.2.1 邻接矩阵法"></a>6.2.1 邻接矩阵法</h3><blockquote>
<p>以顶点做表格，两个顶点之间有连接记为1，没有记为0</p>
</blockquote>
<p>数组实现，因为空间复杂度高，适合存储稠密图。</p>
<p><strong>顺序表（邻接矩阵）表示法</strong></p>
<p>①建立一个顶点表（记录各顶点信息）和一个邻接矩阵（表示各顶点之间关系）</p>
<p>②结点数为n的图G=(V,E)的邻接矩阵A是n×n的。将G的顶点编号为$v_1,v_2,…,v_n$，则</p>
<script type="math/tex; mode=display">
A.Edge[i][j]=\begin{cases}1,　　如果　<v_i,v_j>或者(v_i,v_j)是E(G)中的边\\
0,　　反之
\end{cases}</script><p><strong>无向图的邻接矩阵表示法</strong></p>
<p><img src="../../../images/数据结构/1619600884-image-20210428170804280.png" alt="image-20210428170804280"></p>
<blockquote>
<p>特点1：无向图的邻接矩阵是对称的；</p>
<p>特点2：顶点i 的度＝第 i 行 (列) 中1 的个数；$如：D(v_3)=3$</p>
<p>特点3：完全图的邻接矩阵中，对角元素为0，其余为1。</p>
</blockquote>
<p><strong>有向图的邻接矩阵表示法</strong></p>
<p><img src="../../../images/数据结构/1619601939-image-20210428172539618.png" alt="image-20210428172539618"></p>
<p>注意：在有向图的邻接矩阵中，</p>
<p>　　　第i行含义：以结点$v_i$为尾的弧（即出度边）；</p>
<p>　　　第i列含义：以结点$v_i$为头的弧（即入度边）。</p>
<blockquote>
<p>特点1：有向图的邻接矩阵可能是不对称的。</p>
<p>特点2：顶点的出度=第i行元素之和</p>
<p>　　　　顶点的入度=第i列元素之和</p>
<p>　　　　顶点的度=第i行元素之和+第i列元素之和</p>
</blockquote>
<p><strong>邻接矩阵的性质</strong>：</p>
<p>1.==邻接矩阵法求顶点的度/出度/入度的时间复杂度是$O(|V|)$==</p>
<p>2.设图G的邻接矩阵A，则$A^n$的元素$A^n[i][j]$意思是由顶点i到顶点j的长度为n的路径的数目</p>
<p><strong>网（有权图）的邻接矩阵表示法</strong></p>
<p>定义为：</p>
<script type="math/tex; mode=display">
N.Edge[i][j]=\begin{cases}
W_{ij}　　<v_i,v_j>或(v_i,v_j){\in}V_R\\
\infty　　　无边（弧）
\end{cases}</script><p><img src="../../../images/数据结构/1619655052-image-20210429081052350.png" alt="image-20210429081052350"></p>
<p><strong>邻接矩阵的存储表示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100<span class="comment">//顶点最大数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY <span class="comment">//最大的int值，表示无穷大</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;MGragp;</span><br></pre></td></tr></table></figure>
<p><strong>算法：采用邻接矩阵表示法创建无向网</strong></p>
<blockquote>
<p>算法步骤：</p>
<p>①输入总顶点数和总边数</p>
<p>②依次输入店的信息存入顶点表中</p>
<p>③初始化邻接矩阵，使每个权值初始化为极大值。</p>
<p>④构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//依次输入点的信息</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.vexs[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//初始化邻接矩阵，边的权值均值为极大值MaxInt</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G&gt;vexnum;j++)</span><br><span class="line">            G.arcs[i][j]=MaxInt;<span class="comment">//构造邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g.arcnum;k++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i=LocateVex(G,v1);j=LocateVex(G,v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标</span></span><br><span class="line">        G.arcs[i][j]=w;<span class="comment">//边&lt;v1,v2&gt;的权值为w</span></span><br><span class="line">        G.arcs[j][i]=G.arcs[i][j];<span class="comment">//置&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;的权值为w</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>算法分析</p>
<p>该算法的时间复杂度是$O(n^2)$。</p>
</blockquote>
<h3 id="6-2-2-邻接表法"><a href="#6-2-2-邻接表法" class="headerlink" title="6.2.2  邻接表法"></a>6.2.2  邻接表法</h3><p>顺序+链式存储，适合存储稀疏图</p>
<p>定义邻接表存储：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//边数和条数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义存储顶点信息的结构体:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *first;</span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br></pre></td></tr></table></figure>
<p>定义存储边信息的结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//边指向哪个节点</span></span><br><span class="line">    ArcNode *next;<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/数据结构/image-20220715212455370.png" alt="image-20220715212455370"></p>
<p><img src="../../../images/数据结构/image-20220715212302470.png" alt="image-20220715212302470"></p>
<p><strong>邻接表和邻接矩阵对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:left">邻接矩阵</th>
<th>邻接表</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间复杂度</td>
<td style="text-align:left">$O(</td>
<td>V</td>
<td>^2)$</td>
<td>无向图$O(</td>
<td>V</td>
<td>+2</td>
<td>E</td>
<td>)$；有向图 $O(</td>
<td>V</td>
<td>^2)$</td>
</tr>
<tr>
<td>适用于</td>
<td style="text-align:left">存储稠密图</td>
<td>存储稀疏图</td>
</tr>
<tr>
<td>表示方式</td>
<td style="text-align:left">唯一</td>
<td>不唯一</td>
</tr>
<tr>
<td>计算度/入度/出度</td>
<td style="text-align:left">遍历对应行/列</td>
<td>除了有向图的度和入度，其余很方便</td>
</tr>
<tr>
<td>找相邻的边</td>
<td style="text-align:left">遍历对应行/列</td>
<td>找有向图的入边不方便，其余很方便</td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-2-3-十字链表法和邻接多重表"><a href="#6-2-3-十字链表法和邻接多重表" class="headerlink" title="6.2.3 十字链表法和邻接多重表"></a>6.2.3 十字链表法和邻接多重表</h3><p><strong>1.十字链表法：只存储有向图</strong></p>
<p><img src="../../../images/数据结构/image-20220715213701703.png" alt="image-20220715213701703"></p>
<p>==按照绿色找出边，按照橙色找入边==</p>
<p>性能分析：</p>
<p>空间复杂度：$O(|V|+|E|)$</p>
<p><strong>2.邻接多重表：只存储无向图</strong></p>
<p>删除边、删除结点等操作很方便</p>
<p><img src="../../../images/数据结构/image-20220715214255303.png" alt="image-20220715214255303"></p>
<h3 id="6-2-4-图的基本操作"><a href="#6-2-4-图的基本操作" class="headerlink" title="6.2.4 图的基本操作"></a>6.2.4 图的基本操作</h3><p><img src="../../../images/数据结构/image-20220715214709815.png" alt="image-20220715214709815"></p>
<p><strong>1.判断图G是否存在<x,y>或(x,y)</strong></p>
<p>无向图/有向图：</p>
<ul>
<li><p>邻接矩阵</p>
<p>只需要判断矩阵表中相应位是否等于1，需要O(1)的时间复杂度</p>
</li>
<li><p>邻接表</p>
<p>最好情况：目标结点为第一个连接的边，O(1)</p>
<p>最坏情况：遍历完结点所连接的E-1条边，O(E-1)</p>
</li>
</ul>
<p><strong>2.列出图G中与结点x邻接的边</strong></p>
<p>有向图/无向图</p>
<ul>
<li><p>邻接矩阵：</p>
<p>遍历某行或者某列，输出值为1的元素，O(V)</p>
</li>
<li><p>邻接表：</p>
<p>最好情况：所连边只有一个，O(1)</p>
<p>最坏情况：遍历完所连接的边，O(V)</p>
</li>
</ul>
<p><strong>3.在图G中插入顶点x</strong></p>
<p><img src="../../../images/数据结构/image-20220720155802492.png" alt="image-20220720155802492"></p>
<ul>
<li><p>邻接矩阵：</p>
<p>在方阵后新加入一行一列，O(1)</p>
</li>
<li><p>邻接表：</p>
<p>在表末尾插入一个新元素，O(1)</p>
</li>
</ul>
<p><strong>4.在图G中删除顶点x</strong></p>
<p><img src="../../../images/数据结构/image-20220720160114186.png" alt="image-20220720160114186"></p>
<ul>
<li><p>邻接矩阵：</p>
<p>将该行该列元素全置空，O(V)，【用一个bool型变量，判断结点是否为空】</p>
</li>
<li><p>邻接表：</p>
<p>最好情况：该结点并没有连边，O(1)</p>
<p>最坏情况：当前删除的顶点后边连接了尽可能多的边，这样导致该结点连接在了所有的边上，O(E)</p>
</li>
</ul>
<p><strong>5.若无向边(x,y)或者有向<x,y>不存在，则向图G中添加该边</strong></p>
<p><img src="../../../images/数据结构/image-20220720160848637.png" alt="image-20220720160848637"></p>
<ul>
<li><p>邻接矩阵：</p>
<p>只需要更改该结点的值为1，O(1)</p>
</li>
<li><p>邻接表：</p>
<p>需要在这两个结点的位置头插法或尾插法，如上图，O(1)</p>
</li>
</ul>
<p><strong>6.求图G中顶点x的第一个邻接点，若有则返回顶点号；若x没有邻接点或图中不存在x，则返回-1</strong></p>
<ul>
<li><p>邻接矩阵：</p>
<p>扫描该行直到第一个1，最好O(1)，最坏O(V)</p>
</li>
<li><p>邻接表</p>
<p>该结点链表中的第一个顶点，O(1)</p>
</li>
</ul>
<p><strong>7.假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</strong></p>
<ul>
<li><p>邻接矩阵：</p>
<p>扫描该行的值直到第二个1，O(1)~O(V)</p>
</li>
<li><p>邻接表：</p>
<p>该结点链表中的第一个的下一个顶点，O(1)</p>
</li>
</ul>
<h2 id="6-3-图的遍历"><a href="#6-3-图的遍历" class="headerlink" title="6.3 图的遍历"></a>6.3 图的遍历</h2><h3 id="6-3-1-深度优先搜索"><a href="#6-3-1-深度优先搜索" class="headerlink" title="6.3.1 深度优先搜索"></a>6.3.1 深度优先搜索</h3><p>对于一个连通图，深度优先搜索遍历的过程如下：</p>
<blockquote>
<p>①从图中某个顶点v出发，访问v。</p>
<p>②找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问的顶点没有被访问的邻接点为止。</p>
<p>③返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</p>
<p>④重复步骤②和③，直至图中所有顶点都被访问过，搜索结束。</p>
</blockquote>
<p><img src="../../../images/数据结构/20210602-image-20210602230209346.png" alt="image-20210602230209346" style="zoom: 33%;" /></p>
<p>访问顺序是：$v_1-&gt;v_2-&gt;v_4-&gt;v_8-&gt;v_5-&gt;v_3-&gt;v_6-&gt;v_7$</p>
<h3 id="6-3-2-广度优先搜索"><a href="#6-3-2-广度优先搜索" class="headerlink" title="6.3.2 广度优先搜索"></a>6.3.2 广度优先搜索</h3><p>广度优先搜索遍历过程如下：</p>
<blockquote>
<p>①从图中某个顶点v出发，访问v。</p>
<p>②依次访问v的各个未被访问过的邻接点。</p>
<p>③分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤③，直至图中所有已被访问的顶点的邻接点都被访问到。</p>
</blockquote>
<p>图6.17访问顺序：$v_1-&gt;v_2-&gt;v_3-&gt;v_4-&gt;v_5-&gt;v_6-&gt;v_7-&gt;v_8$</p>
<p><img src="../../../images/数据结构/20210602-image-20210602230310978.png" alt="image-20210602230310978" style="zoom:67%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//初始都为false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了解决非连通图的BFS，调用BFS次数=连通分量数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        visited[i]=FALSE;<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);<span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//从v出发，进行广度优先遍历</span></span><br><span class="line">    visit(v);<span class="comment">//访问初始化顶点v</span></span><br><span class="line">    visited[v]=TRUE;<span class="comment">//对v做标记</span></span><br><span class="line">    Equeue(Q,v);<span class="comment">//v入队</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;<span class="comment">//如果队列不为空</span></span><br><span class="line">        DeQueue(Q,v);<span class="comment">//v出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighBor(G,v,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//如果w是v没被访问过的邻接顶点</span></span><br><span class="line">                visit(w);<span class="comment">//访问w</span></span><br><span class="line">                visited[w]=TRUE;<span class="comment">//将w做标记表示已访问过</span></span><br><span class="line">                EnQueue(Q,w);<span class="comment">//w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-图的应用"><a href="#6-4-图的应用" class="headerlink" title="6.4 图的应用"></a>6.4 图的应用</h2><h3 id="6-4-1-最小生成树"><a href="#6-4-1-最小生成树" class="headerlink" title="6.4.1 最小生成树"></a>6.4.1 最小生成树</h3><p>使边的权值之和最小的生成树</p>
<p>==连通图才有生成树，非连通图只有森林==</p>
<p><strong>1.Prim算法</strong></p>
<p>从某个<font color="red">顶点</font>开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入。$O(v^2)$与顶点有关，适合边稠密图</p>
<p><img src="../../../images/数据结构/image-20220725100148632.png" alt="image-20220725100148632"></p>
<p>邻接表存储的时间复杂度：O(n+e)</p>
<p><strong>2.Kruskal算法</strong></p>
<p>每次选择一条权值<font color="red">最小的边</font>，使这条边的两头连通（已连通就不选），直到所有结点连通。$O(Elog_2E)$与边有关，适合边稀疏图</p>
<p><img src="../../../images/数据结构/image-20220725100210983.png" alt="image-20220725100210983"></p>
<h3 id="6-4-2-最短路径问题"><a href="#6-4-2-最短路径问题" class="headerlink" title="6.4.2 最短路径问题"></a>6.4.2 最短路径问题</h3><script type="math/tex; mode=display">
最短路径问题\begin{cases}单源最短路径\begin{cases}BFS算法（无权图）\\\\Djkstra算法（带权图、无权图）\end{cases}\\\\
各顶点间的最短路径：Floyd算法（带权图、无权图）\end{cases}</script><p><strong>1.Djkstra算法</strong></p>
<p><img src="../../../images/数据结构/image-20220720215259505.png" alt="image-20220720215259505"></p>
<p><img src="../../../images/数据结构/image-20220725150523041.png" alt="image-20220725150523041"></p>
<p><strong>2.Floyd算法</strong></p>
<p>求每一对顶点之间的最短路径</p>
<blockquote>
<p>使用动态规划的思想，将问题的求解分为多个阶段</p>
<p>对于n个顶点的图G，求任意一对顶点$v_i$—&gt;$v_j$之间的最短路径课分为如下几个阶段：</p>
<h1 id="0：若允许在-v-0-中转，最短路径为？"><a href="#0：若允许在-v-0-中转，最短路径为？" class="headerlink" title="0：若允许在$v_0$中转，最短路径为？"></a>0：若允许在$v_0$中转，最短路径为？</h1><h1 id="1：若允许在-v-0、v-1-中转，最短路径为？"><a href="#1：若允许在-v-0、v-1-中转，最短路径为？" class="headerlink" title="1：若允许在$v_0、v_1$中转，最短路径为？"></a>1：若允许在$v_0、v_1$中转，最短路径为？</h1><h1 id="2：若允许在-v-0、v-1、v-2-中转，最短路径为？"><a href="#2：若允许在-v-0、v-1、v-2-中转，最短路径为？" class="headerlink" title="2：若允许在$v_0、v_1、v_2$中转，最短路径为？"></a>2：若允许在$v_0、v_1、v_2$中转，最短路径为？</h1><p>···</p>
<h1 id="n-1：若允许在-v0、v-1、v-2…v-n-1-中转，最短路径为？"><a href="#n-1：若允许在-v0、v-1、v-2…v-n-1-中转，最短路径为？" class="headerlink" title="n-1：若允许在$v0、v_1、v_2…v{n-1}$中转，最短路径为？"></a>n-1：若允许在$v<em>0、v_1、v_2…v</em>{n-1}$中转，最短路径为？</h1></blockquote>
<p><img src="../../../images/数据结构/image-20220725103236328.png" alt="image-20220725103236328"></p>
<h3 id="6-4-3-有向无环图"><a href="#6-4-3-有向无环图" class="headerlink" title="6.4.3 有向无环图"></a>6.4.3 有向无环图</h3><p>若一个有向图不存在环，就是有向无环图，简称DAG图</p>
<p><strong>1.有向无环图来描述表达式</strong></p>
<p><img src="../../../images/数据结构/image-20220721174159591.png" alt="image-20220721174159591"></p>
<h3 id="6-4-4-AOV-网"><a href="#6-4-4-AOV-网" class="headerlink" title="6.4.4 AOV 网"></a>6.4.4 AOV 网</h3><p>AOV网（Activity On Vertex NetWork，==用顶点表示活动==的网）：用DAG图表示一个工程。顶点表示活动，有向边$<v_i,v_j>$表示活动$v_i$必须先于$v_j$活动</p>
<p>例子：各个课程为一个点，学了c语言才能学java，学了java才能学python，边是有向边</p>
<p>特性：</p>
<ul>
<li>1先于2,2先于3，则1先于3</li>
<li>拓扑排序后的序列不唯一</li>
</ul>
<h3 id="6-4-5-拓扑排序"><a href="#6-4-5-拓扑排序" class="headerlink" title="6.4.5 拓扑排序"></a>6.4.5 拓扑排序</h3><p>求顺序</p>
<p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p>
<p>①每个顶点出现且只出现一次</p>
<p>②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。</p>
<p><strong>一般步骤：</strong></p>
<p>①从AOV网中选择入度为0的顶点</p>
<p>②删除该顶点与其他顶点的连线后，输出该顶点</p>
<p>③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止</p>
<p><strong>代码实现：</strong></p>
<p>采用邻接表的实现：</p>
<p>indegree[]：当前顶点入度</p>
<p>print[]：记录拓扑排序</p>
<p><img src="../../../images/数据结构/image-20220724170023428.png" alt="image-20220724170023428"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100<span class="comment">//图中顶点数的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">    ArcNode *nextarc;<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125;Graph;<span class="comment">//Graph是以邻接表存储的图的类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    InitStack(S);<span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">            Push(S,i);<span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(S))&#123;<span class="comment">//栈不为空，则存在入度为0的顶点</span></span><br><span class="line">        Pop(S,i);<span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++]=i;<span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            <span class="comment">//将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S中</span></span><br><span class="line">            v=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))</span><br><span class="line">                Push(S,v);<span class="comment">//入度为0，则入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排序失败，有向图有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-6-关键路径"><a href="#6-4-6-关键路径" class="headerlink" title="6.4.6 关键路径"></a>6.4.6 关键路径</h3><p>关键路径：从原点到汇点的有向路径有多条，在所有路径中，具有最大路径长度的路径称为关键路径，该路径上的活动称为关键活动。是求最长活动路径</p>
<p><strong>1.AOE网</strong>：</p>
<blockquote>
<p>在带权有向图中，==以顶点表示事件，以有向边表示活动==，以边上的权值表示完成该活动的开销（如完成活动所需要的时间），称为用边表示活动的网络，简称AOE网。</p>
<p>开始顶点（源点）：仅有一个入度为0</p>
<p>结束顶点（汇点）：仅有一个出度为0</p>
</blockquote>
<p>性质：</p>
<ul>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li>
<li>只有在进入某顶点的各有向边所代表的的活动都已结束时，该顶点所代表的事件才能发生。另外有些活动是可以并行进行。</li>
</ul>
<p><strong>2.基本概念</strong></p>
<script type="math/tex; mode=display">
1.事件v_k的最早发生时间ve(k)——决定了所有从v_k开始的活动能够开工的最早时间。\\
2.活动a_i的最早开始时间e(i)——指该活动弧的起点所表示的事件的最早发生时间。\\
3.事件v_k的最迟发生时间vl(k)——是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。\\
4.活动a_i的最迟开始时间l(i)——该活动弧的终点所表示事件最迟发生时间与该活动所需时间之差。\\
5.活动a_i的时间余量d(i)=l(i)-e(i)，表示在不增加完成整个工程所需总时间的情况下，活动a_i可以拖延的时间，\\若一个活动的时间余量为0，则说明该活动必须如期完成，d(i)=0即l(i)=e(i)的活动a_i是关键活动。</script><p><strong>3.求关键路径的步骤</strong></p>
<p><img src="../../../images/数据结构/image-20220922163420309.png" alt="image-20220922163420309"></p>
<p>$拓扑序列为：v_1，v_3，v_2，v_5，v_4，v_6$</p>
<p><img src="../../../images/数据结构/image-20220922164016078.png" alt="image-20220922164016078" style="zoom: 80%;" /></p>
<p><img src="../../../images/数据结构/image-20220922164253274.png" alt="image-20220922164253274" style="zoom:80%;" /></p>
<p><img src="../../../images/数据结构/image-20220922164543414.png" alt="image-20220922164543414" style="zoom:80%;" /></p>
<p><img src="../../../images/数据结构/image-20220922164709356.png" alt="image-20220922164709356" style="zoom:80%;" /></p>
<p><img src="../../../images/数据结构/image-20220922165034160.png" alt="image-20220922165034160" style="zoom:80%;" /></p>
<p><img src="../../../images/数据结构/image-20220922165107744.png" alt="image-20220922165107744" style="zoom:80%;" /></p>
<blockquote>
<p>①求所有事件最早发生时间ve();</p>
<p>按拓扑排序序列，依次求各个顶点的ve(k)；</p>
<p>ve(源点)=0</p>
<p>$ve(k)=Max{ve(j)+Weight(v_j,v_k)}，v_j为v_k的任意前驱$</p>
<p>②求所有事件最迟发生时间vl();</p>
<p>③求所有活动的最早发生时间e();</p>
<p>④求所有活动的最迟发生时间l();$vl-weight(v_j,v_k)$</p>
<p>⑤求所有活动的时间余量d();</p>
</blockquote>
<p><img src="../../../images/数据结构/image-20220724172040671.png" alt="image-20220724172040671"></p>
<h1 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h1><h2 id="7-1-查找的基本概念"><a href="#7-1-查找的基本概念" class="headerlink" title="7.1 查找的基本概念"></a>7.1 查找的基本概念</h2><ul>
<li><p>查找表:</p>
<p>由同一类型的数据元素（或记录）构成的集合</p>
</li>
<li><p>静态查找表：</p>
<p>查找的同时对查找表不做修改操作（如插入和删除）</p>
</li>
<li><p>动态查找表：</p>
<p>查找的同时对查找表具有修改操作</p>
</li>
<li><p>关键字</p>
<p>记录中某个数据项的值，可用来识别一个记录</p>
</li>
<li><p>主关键字：</p>
<p>唯一标识数据元素的值</p>
</li>
<li><p>次关键字：<br>可以标识若干个数据元素</p>
</li>
<li><p>平均查找长度（关键字的平均比较次数）</p>
</li>
</ul>
<script type="math/tex; mode=display">
ASL=\sum_{i=1}^{n}p_ic_i\\n：记录的个数\\

p_i：查找第i个记录的概率（通常认为$p_i$=1/n）\\

c_i：找到第i个记录所需的比较次数</script><p><strong>查找算法的评价指标：</strong></p>
<p>查找长度——在查找运算中，需要对比关键字的次数称为查找长度</p>
<p>平均查找长度（ASL，Average Search Length）——所有查找过程中进行关键字的比较次数的平均值</p>
<h2 id="7-2-线性表的查找"><a href="#7-2-线性表的查找" class="headerlink" title="7.2 线性表的查找"></a>7.2 线性表的查找</h2><h3 id="7-2-1-顺序查找"><a href="#7-2-1-顺序查找" class="headerlink" title="7.2.1 顺序查找"></a>7.2.1 顺序查找</h3><p>顺序查找适用于顺序结构，也适用于链式结构</p>
<p>数据元素类型的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> TableLen;</span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure>
<p>算法步骤：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.TableLen &amp;&amp; ST.elem[i].key!=key;++i)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法的时间复杂度是O(n)</p>
<p>最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)</p>
<p>最坏情况：查找的元素在表尾（或不存在），需要比较n次，时间复杂度为O(n)</p>
<p>平均查找长度：$ASL=\frac{1}{n}\sum_{i=1}^{n}i=\frac{1+2+3+…+n}{n}=\frac{n+1}{2}$</p>
<h3 id="7-2-2-折半查找"><a href="#7-2-2-折半查找" class="headerlink" title="7.2.2 折半查找"></a>7.2.2 折半查找</h3><p>只适用于顺序结构</p>
<p>算法步骤：</p>
<blockquote>
<p>①置查找区间初值，low为1，high为表长</p>
<p>②当low小于等于high时，循环执行以下操作</p>
<ul>
<li>mid取值为low和high的中间值</li>
<li>将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid；</li>
<li>若不想等则利用中间位置记录将表对分成前、后两个子表。如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1。</li>
</ul>
<p>③循环结束，说明查找区间为空，则查找失败，返回0。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    low=<span class="number">1</span>;high=ST.length;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key==ST.R[mid].key) </span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">            (key&lt;ST.R[mid].key) high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/数据结构/image-20220926093651305.png" alt="image-20220926093651305"></p>
<p>时间复杂度是$O(log_2n)$</p>
<p>平均查找长度：$判断树层数*该层个数，之后累加：ASL=\sum<em>{i=1}^{n}P_iC_i=\frac{1}{n}\sum</em>{j=1}^{h}j·2^{j-1}=\frac{n+1}{n}log_2(n+1)-1$</p>
<p>当n较大时近似为：$ASL=log_2(n+1)-1$</p>
<h3 id="7-2-3-分块查找"><a href="#7-2-3-分块查找" class="headerlink" title="7.2.3 分块查找"></a>7.2.3 分块查找</h3><p><strong>1.算法思想</strong></p>
<p><img src="../../../images/数据结构/image-20220724173535397.png" alt="image-20220724173535397"></p>
<p>索引块中保存每个分块的最大关键字和分块的存储区间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//索引表</span></span><br><span class="line">    ElemType maxValue;</span><br><span class="line">    <span class="keyword">int</span> low,high;</span><br><span class="line">&#125;Index;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表存储实际元素</span></span><br><span class="line">ElemType List[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<p><strong>2.算法过程：</strong></p>
<p>①在索引表中确定待查记录的所属分块（可顺序，可折半）</p>
<p>②在块中顺序查找</p>
<p><strong>3.查找效率分析</strong></p>
<p>假设，长度为n的查找表被均匀的分为b块，每块s个元素[n=sb]</p>
<p>设索引查找和块内查找的平均查找长度分别为$L_1、L_s$，则分块查看的平均查找长度为$ASL=L_1+L_s$</p>
<p>用顺序查找查索引表，则</p>
<script type="math/tex; mode=display">
L_1=\frac{1+2+...+b}{b}=\frac{b+1}{2}，L_s=\frac{1+2+...+s}{s}=\frac{s+1}{2}\\
则ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s},当s=\sqrt{n}时，ASL_{最小}=\sqrt{n}+1</script><p>用折半查找查索引表，则</p>
<script type="math/tex; mode=display">
L_1= \lceil log_2(b+1)\rceil,L_s=\frac{1+2+...+s}{s}=\frac{s+1}{2}\\
则ASL=\lceil log_2(b+1)\rceil+\frac{s+1}{2}</script><h2 id="7-3-树表的查找"><a href="#7-3-树表的查找" class="headerlink" title="7.3 树表的查找"></a>7.3 树表的查找</h2><h3 id="7-3-1-二叉排序树（BST）"><a href="#7-3-1-二叉排序树（BST）" class="headerlink" title="7.3.1 二叉排序树（BST）"></a>7.3.1 二叉排序树（BST）</h3><p>二叉排序树或是空树，或是满足如下性质的二叉树：左子树结点值&lt;根结点值&lt;右子树结点值</p>
<p> (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值；</p>
<p> (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值；</p>
<p> (3)其左右子树本身又各是一棵二叉排序树</p>
<p>结点的数据域的类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Struct&#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    IndoType otherindo;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br></pre></td></tr></table></figure>
<p><strong>1.二叉排序树的递归查找</strong></p>
<blockquote>
<p>①若二叉排序树为空，则查找失败，返回空指针。</p>
<p>②若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较：</p>
<ul>
<li>若key等于T-&gt;data.key，则查找成功，返回根节点地址</li>
<li>若key小于T-&gt;data.key，则递归查找左子树</li>
<li>若key大于T-&gt;data.key，则递归查找右子树</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((!T) || key==T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.二叉排序树非递归查找</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key) T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.二叉排序树的插入</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==NUll)&#123;<span class="comment">//原树如果为空，新插入的结点为根结点</span></span><br><span class="line">        T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key=k;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.二叉排序树的删除</strong></p>
<p>①若被删除结点z是叶子结点，直接删除</p>
<p>②若结点z只有一颗左子树或者右子树，直接将子树替代z</p>
<p>③若结点z有左右两颗子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），就转换为了①或②的情况</p>
<p><strong>5.查找效率分析</strong></p>
<p>查找成功：</p>
<ul>
<li><p>最好情况：n个结点的二叉树最小高度为$\lfloor log_2n\rfloor+1$，平均查找长度=$O(log_2n)$</p>
</li>
<li><p>最坏情况：每个结点只有一个分支，树高h=结点数n，平均查找长度=$O(n)$</p>
</li>
</ul>
<p>查找失败：</p>
<ul>
<li><p>补齐空节点，然后计算</p>
<p><img src="../../../images/数据结构/image-20220724204617958.png" alt="image-20220724204617958"></p>
</li>
</ul>
<h3 id="7-3-2-平衡二叉树"><a href="#7-3-2-平衡二叉树" class="headerlink" title="7.3.2 平衡二叉树"></a>7.3.2 平衡二叉树</h3><p><strong>1.AVL树简介</strong></p>
<blockquote>
<p>AVL树的名字来源于它的发明作者G.M. Adelson-Velsky 和 E.M. Landis。AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）。</p>
<p>平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：==它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1==，且它的左子树和右子树都是一颗平衡二叉树。</p>
</blockquote>
<p>平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：</p>
<p>　1.左子树和右子树也是平衡二叉树</p>
<p>　2.每个结点的左子树和右子树高度差最多为1</p>
<p><img src="../../../images/数据结构/20210526-image-20210526175341516.png" alt="image-20210526175341516"></p>
<p>图一中左边二叉树的节点45的左孩子46比45大，不满足二叉搜索树的条件，因此它也不是一棵平衡二叉树。</p>
<p>右边二叉树满足二叉搜索树的条件，同时它满足条件二，因此它是一棵平衡二叉树。</p>
<p><img src="../../../images/数据结构/20210527-image-20210527080726469.png" alt="image-20210527080726469"></p>
<p>左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2，不满足条件二；</p>
<p>右边二叉树的节点均满足左右子树高度差至多为1，同时它满足二叉搜索树的要求，因此它是一棵平衡二叉树。</p>
<p>AVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），这得益于它时刻维护着二叉树的平衡。如果我们需要查找的集合本身没有顺序，在频繁查找的同时，也经常的插入和删除，AVL树是不错的选择。不平衡的二叉查找树在查找时的效率是很低的，因此，AVL如何维护二叉树的平衡是我们的学习重点。</p>
<p><strong>2.AVL树相关概念</strong></p>
<ol>
<li><p><strong>平衡因子</strong>：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。</p>
<p>在图二右边的AVL树上：</p>
<p>节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1；</p>
<p>节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1；</p>
<p>节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0；</p>
<p>节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1；</p>
<p>对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。</p>
</li>
<li><p>最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树.。</p>
<p><img src="../../../images/数据结构/20210527-image-20210527081029408.png" alt="image-20210527081029408"></p>
</li>
</ol>
<p>在图三中，左边二叉树的节点45的BF = 1，插入节点43后，节点45的BF = 2。节点45是距离插入点43最近的BF不在[-1,1]范围内的节点，因此以节点45为根的子树为最小不平衡子树。</p>
<p><strong>3.AVL树的平衡调整</strong></p>
<p>定义平衡二叉树结点结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>
<p>整个实现过程是通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。分为LL型、RR型、LR型和RL型4种类型，各调整方法如下(下面用A表示最低不平衡结点)：</p>
<ol>
<li>LL型调整：</li>
</ol>
<blockquote>
<p>由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527081355420.png" alt="image-20210527081355420"></p>
<blockquote>
<p>LL型调整的一般形式如下图2所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：==①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。==</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527081640790.png" alt="image-20210527081640790"></p>
<p>代码实现：</p>
<p><img src="../../../images/数据结构/20210527-image-20210527081706164.png" alt="image-20210527081706164"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">ll_rotate</span><span class="params">(BTNode *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;   </span><br><span class="line"> </span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>RR型调整：</li>
</ol>
<blockquote>
<p>由于在A的右孩子(R)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图3是RR型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B逆时针旋转一样。</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527081850609.png" alt="image-20210527081850609"></p>
<blockquote>
<p>RR型调整的一般形式如下图4所示，表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：</p>
<p>==将A的右孩子B提升为新的根结点；<br>将原来的根结点A降为B的左孩子<br>各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。==</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527081924315.png" alt="image-20210527081924315"></p>
<p>代码实现：</p>
<p><img src="../../../images/数据结构/20210527-image-20210527081948695.png" alt="image-20210527081948695"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">rr_rotate</span><span class="params">(struct Node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>LR型调整</li>
</ol>
<blockquote>
<p>由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527082030489.png" alt="image-20210527082030489"></p>
<blockquote>
<p>LR型调整的一般形式如下图6所示，表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：==①将B的右孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。==</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527082102010.png" alt="image-20210527082102010"></p>
<p>代码实现：</p>
<p><img src="../../../images/数据结构/20210527-image-20210527082126473.png" alt="image-20210527082126473"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">lr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x = y-&gt;left;</span><br><span class="line">    y-&gt;left = rr_rotate(x);</span><br><span class="line">    <span class="keyword">return</span> ll_rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>RL型调整：</li>
</ol>
<blockquote>
<p>由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527082230583.png" alt="image-20210527082230583"></p>
<blockquote>
<p>RL型调整的一般形式如下图8所示，表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：==①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。==</p>
</blockquote>
<p><img src="../../../images/数据结构/20210527-image-20210527082324312.png" alt="image-20210527082324312"></p>
<p>代码实现：</p>
<p><img src="../../../images/数据结构/20210527-image-20210527082352452.png" alt="image-20210527082352317"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">lr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x = y-&gt;left;</span><br><span class="line">    y-&gt;left = rr_rotate(x);</span><br><span class="line">    <span class="keyword">return</span> ll_rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入和删除完整代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct Node *N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> N-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> =</span> (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;height = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">ll_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"></span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">rr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line"></span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(BTNode* N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> height(N-&gt;left) - height(N-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function">BTNode* <span class="title">insert</span><span class="params">(BTNode* node, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    node-&gt;height = <span class="number">1</span> + max(height(node-&gt;left), height(node-&gt;right));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)     <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key)     <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;left = rr_rotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key)     <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;right = ll_rotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BTNode * <span class="title">minValueNode</span><span class="params">(BTNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* current = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">BTNode* <span class="title">deleteNode</span><span class="params">(BTNode* root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;left == <span class="literal">NULL</span>) || (root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *root = *temp;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = minValueNode(root-&gt;right);</span><br><span class="line"></span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line"></span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    root-&gt;height = <span class="number">1</span> + max(height(root-&gt;left), height(root-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="number">0</span>) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="number">0</span>) <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = rr_rotate(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="number">0</span>)  <span class="comment">//Rl型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = ll_rotate(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;key);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    root = insert(root, <span class="number">9</span>);</span><br><span class="line">    root = insert(root, <span class="number">5</span>);</span><br><span class="line">    root = insert(root, <span class="number">10</span>);</span><br><span class="line">    root = insert(root, <span class="number">0</span>);</span><br><span class="line">    root = insert(root, <span class="number">6</span>);</span><br><span class="line">    root = insert(root, <span class="number">11</span>);</span><br><span class="line">    root = insert(root, <span class="number">-1</span>);</span><br><span class="line">    root = insert(root, <span class="number">1</span>);</span><br><span class="line">    root = insert(root, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历：\n&quot;</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The constructed AVL Tree would be</span></span><br><span class="line"><span class="comment">                     9</span></span><br><span class="line"><span class="comment">                    /  \</span></span><br><span class="line"><span class="comment">                   1    10</span></span><br><span class="line"><span class="comment">                 /  \     \</span></span><br><span class="line"><span class="comment">                0    5     11</span></span><br><span class="line"><span class="comment">               /    /  \</span></span><br><span class="line"><span class="comment">              -1   2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    root = deleteNode(root, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* The AVL Tree after deletion of 10</span></span><br><span class="line"><span class="comment">                       1</span></span><br><span class="line"><span class="comment">                     /   \</span></span><br><span class="line"><span class="comment">                    0     9</span></span><br><span class="line"><span class="comment">                  /     /  \</span></span><br><span class="line"><span class="comment">                -1     5     11</span></span><br><span class="line"><span class="comment">                     /  \</span></span><br><span class="line"><span class="comment">                    2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历：\n&quot;</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-B树"><a href="#7-3-3-B树" class="headerlink" title="7.3.3 B树"></a>7.3.3 B树</h3><p><strong>1.基本概念</strong></p>
<p><img src="../../../images/数据结构/image-20220725151333348.png" alt="image-20220725151333348"></p>
<p>若每个结点内的关键字太少，导致树变高，要查更多层结点，导致效率低。</p>
<ul>
<li>m叉查找树中，规定除了根结点外，任何结点至少有$\lceil\frac{m}{2}\rceil$个分叉，即至少含有$\lceil\frac{m}{2}\rceil-1$个关键字</li>
<li>m叉查找树中，尽量保证所有子树高度相同</li>
</ul>
<blockquote>
<p>B树，又称为多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一颗m阶B树或为空树，或为满足如下特性的m叉树：</p>
<p>①树中每个结点至多有m颗子树，即至多含有m-1个关键字</p>
<p>②若根结点不是终端结点，则至少有两颗子树</p>
<p>③m叉查找树中，规定除了根结点外，任何结点至少有$\lceil\frac{m}{2}\rceil$个分叉，即至少含有$\lceil\frac{m}{2}\rceil-1$个关键字</p>
<p>④所有的叶子结点都出现同一层上，并且不带信息</p>
<p>⑤所有非叶结点的结果如下：</p>
</blockquote>
<p>$|　n　|　P_0　|　K_1　|　P_1　|　K_2　|　P_2　|　…　|　K_n　|　P_n　|$</p>
<p>其中，$K_i(i=1,2,3,…,n)$为结点的关键字，且满足$K_1&lt;K_2&lt;…&lt;K_n$；$P_i(i=0,1,…,n)$为指向子树根结点的指针，且指针$P_i-1$所指子树中所有结点的关键字均小于$K_i$，$P_i$所指子树中所有结点的关键字均大于$K_i$，$n(\lceil\frac{m}{2}\rceil-1) \le n \le m-1$，为节点中关键字的个数。</p>
<p><strong>2.B树的高度</strong></p>
<p>含n个关键字的m叉B树，高度$\textcolor{red}{ log<em>m(n+1) \le h \le log</em>{\lceil\frac{m}{2}\rceil}\frac{n+1}{2}+1}$</p>
<p>B树的高度一般不包括失败节点（叶子结点）</p>
<p>问题1：含n个关键字的m阶B树，最小高度，最大高度？</p>
<script type="math/tex; mode=display">
最小高度——让每个结点尽可能的填满关键字，有m-1个关键字，m个分叉，则有\\
n \le (m-1)(1+m+m^2+...+m^{h-1})=m^h-1，因此h \ge log_m(n+1)\\\\
最大高度——让各层的分叉尽可能的少，即根结点只有2个分叉，其他节点只有\lceil\frac{m}{2}\rceil个分叉;\\各层结点至少有:第一层1、第二层2、第三层2\lceil\frac{m}{2}\rceil...第h层2(\lceil\frac{m}{2}\rceil)^{h-2};\\
第h+1层共有叶子结点2(\lceil\frac{m}{2}\rceil)^{h-1}个\\
\textcolor{red}{n个关键字的B树必有n+1个叶子结点}，则n+1 \ge \lceil\frac{m}{2}\rceil)^{h-1}，即h \le log_{\lceil\frac{m}{2}\rceil}\frac{n+1}{2}+1</script><p>问题2：含n个关键字的m叉B树，最小高度、最大高度？</p>
<script type="math/tex; mode=display">
最大高度——让每个结点包含的关键字、分叉尽可能地少。记k=\lceil\frac{m}{2}\rceil</script><p><img src="../../../images/数据结构/image-20220725155319842.png" alt="image-20220725155319842"></p>
<p><img src="../../../images/数据结构/image-20220725155508510.png" alt="image-20220725155508510"></p>
<p><strong>3.B树的插入</strong></p>
<p><strong>4.B树的删除</strong></p>
<ul>
<li>删除叶子结点时，兄弟左移</li>
<li>删除根结点，要找到直接前驱或直接后继替换他</li>
<li>借左右兄弟</li>
<li>兄弟不够借，就合并父节点，如果父节点关键字数量小于，可能要继续合并</li>
</ul>
<h3 id="7-3-4-B-树"><a href="#7-3-4-B-树" class="headerlink" title="7.3.4 B+树"></a>7.3.4 B+树</h3><p>一颗m阶的B+树，满足下列条件：</p>
<p>①每个分支节点最多有m棵子树</p>
<p>②非叶根结点至少有两颗子树，其他每个分支结点至少有$\lceil\frac{m}{2}\rceil$棵子树</p>
<p>③结点的子树个数与关键字个数相等</p>
<p>④所有的叶子结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排序，并且相邻叶子结点按大小顺序相互链接起来</p>
<p><strong>1.B+树的查找</strong></p>
<p><img src="../../../images/数据结构/image-20220726090101528.png" alt="image-20220726090101528"></p>
<ul>
<li>从上往下查找</li>
<li>指针p顺序查找</li>
</ul>
<p><strong>2.B树和B+树的区别</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">m阶B树</th>
<th style="text-align:left">m阶B+树</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">关键字与分叉</td>
<td style="text-align:left">结点中n个关键字对应n+1棵子树</td>
<td style="text-align:left">结点中n个关键字对应n个子树</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">根结点关键字树$n \in [1,m-1]$；其他节点关键字数$n \in [\lceil\frac{m}{2}\rceil-1,m-1]$</td>
<td style="text-align:left">根结点的关键字数$n \in [1,m]$；其他结点的关键字数$n \in [\lceil\frac{m}{2}\rceil,m]$</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">各结点中的关键字不重复</td>
<td style="text-align:left">叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">结点中包含了关键字对应的记录的存储地址</td>
<td style="text-align:left">叶结点包含信息，非叶结点仅有索引作用</td>
</tr>
<tr>
<td style="text-align:left">查找方式</td>
<td style="text-align:left">不支持顺序查找。查找成功时，可能停在任何一层结点，查找速度“不稳定”</td>
<td style="text-align:left">支持顺序查找。查找成功或失败都会到达最下一层结点，查找速度“稳定”</td>
</tr>
</tbody>
</table>
</div>
<p>相同点：除根节点意外，最少有$\lceil\frac{m}{2}\rceil$个子树；任一结点的子树都一样高</p>
<h2 id="7-4-散列查找"><a href="#7-4-散列查找" class="headerlink" title="7.4 散列查找"></a>7.4 散列查找</h2><h3 id="7-4-1-散列表基本概念"><a href="#7-4-1-散列表基本概念" class="headerlink" title="7.4.1 散列表基本概念"></a>7.4.1 散列表基本概念</h3><p>散列表（Hash Table），又称哈希表，是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关。</p>
<p><img src="../../../images/数据结构/image-20220726092247462.png" alt="image-20220726092247462"></p>
<p>若不同的关键字通过散列函数映射到同一个值，则他们称为同义词</p>
<p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为冲突</p>
<p>解决冲突的方法：</p>
<ul>
<li>拉链法：把所有同义词存储在一个链表中</li>
</ul>
<p><strong>1.查找效率</strong></p>
<p><img src="../../../images/数据结构/image-20220726093422052.png" alt="image-20220726093422052"></p>
<p><img src="../../../images/数据结构/image-20220726093208933.png" alt="image-20220726093208933"></p>
<p>==装填因子α=表中记录数/散列表长度==：装填因子直接影响散列表的查找效率</p>
<h3 id="7-4-2-常见的散列函数（为了使冲突减少）"><a href="#7-4-2-常见的散列函数（为了使冲突减少）" class="headerlink" title="7.4.2 常见的散列函数（为了使冲突减少）"></a>7.4.2 常见的散列函数（为了使冲突减少）</h3><p><strong>1.除留余数法——H(key)=key%p</strong></p>
<p>散列表表长为m，去一个不大于m但最接近或等于m的质数p（除了1和此数自身外不能被其他自然数整除的数）</p>
<p><img src="../../../images/数据结构/image-20220726093718931.png" alt="image-20220726093718931"></p>
<p><strong>2.直接定址法——H(key)=key或H(key)=a*key+b</strong></p>
<p>其中，a和b是常数。这种方法计算最简单，且不会发生冲突。适合<font color="red">关键字的分布基本连续的情况</font>，若关键字分布不连续，空位比较多，则会造成存储空间的浪费</p>
<p><strong>3.数字分析法——选取数码分布较为均匀的若干位作为散列地址</strong></p>
<p>设关键字是r进制数，而<font color="red">r个数码在各位上出现的频率一定不相同，可能在某些位上分布均匀一些</font>，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</p>
<p><strong>4.平均取中法——取关键字的平方值的中间几位作为散列地址</strong></p>
<p>具体取多少位要视情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此是的散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</p>
<p><img src="../../../images/数据结构/image-20220726094638224.png" alt="image-20220726094638224"></p>
<p><strong>5.开放定址法——可存放新表项的空闲地址即向它的同义词表项开放，又向它的非同义词表项开放。</strong>其递推公式：</p>
<script type="math/tex; mode=display">
H_i=(H(key)+d_i)\%m\\
i=0,1,2,...,k(k \le m-1)，m表示散列表表长；d_i为增量序列；i可理解为第i次发生冲突</script><p>①线性探测法——$d_i=0,1,2,3,…,m-1$;即发生冲突时，每次往后探测相邻的下一个单元是否为空。</p>
<p><img src="../../../images/数据结构/image-20220726151146053.png" alt="image-20220726151146053"></p>
<p><img src="../../../images/数据结构/image-20220726151355361.png" alt="image-20220726151355361"></p>
<p>这里，空位置的比较也算作一次，删除元素的时候，需要删除标记（逻辑删除）</p>
<p>②平方探测法：当$d_i=0^2,1^2,-1^2,2^2,-2^2,…k^2,-k^2$时，称为平方探测法$k \le \frac{m}{2}$</p>
<p><img src="../../../images/数据结构/image-20220726151836813.png" alt="image-20220726151836813"></p>
<p>==散列表长度m必须是一个可以表示成4j+3的素数，才能探测到所有位置==</p>
<p>③伪随机序列法：$d_i$是某个伪随机序列</p>
<p><strong>6.再散列法：</strong>除了原始的散列函数H(key)之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：</p>
<script type="math/tex; mode=display">
H_i=RH_i(Key)　　　　i=1,2,3,4,...,k</script><h1 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h1><p>以下算法都会用到的类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;					<span class="comment">//关键字项</span></span><br><span class="line">    InfoType otherinfo;				<span class="comment">//其他数据项</span></span><br><span class="line">&#125;RedType;							<span class="comment">//记录类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    RedType r[MAXSIZE+<span class="number">1</span>];			<span class="comment">//r[0]闲置或用做哨兵单元</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>所有排序算法比较：</p>
<p><img src="../../../images/数据结构/20210527-image-20210527094036260.png" alt="image-20210527094036260"></p>
<h2 id="8-1-插入排序"><a href="#8-1-插入排序" class="headerlink" title="8.1 插入排序"></a>8.1 插入排序</h2><h3 id="8-1-1-直接插入方法排序"><a href="#8-1-1-直接插入方法排序" class="headerlink" title="8.1.1 直接插入方法排序"></a>8.1.1 直接插入方法排序</h3><p>基本操作是将一条记录插入到已排好序的有序表中，从而得到一个新的、记录数量增1的有序表。</p>
<p><img src="../../../images/数据结构/image-20220720200950589.png" alt="image-20220720200950589"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">40</span>, <span class="number">28</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">21</span>, <span class="number">48</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(a) / a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            t = a[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt; <span class="number">-1</span> &amp;&amp; t &lt; a[j]; j--)</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            a[j+<span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-折半插入排序"><a href="#8-1-2-折半插入排序" class="headerlink" title="8.1.2 折半插入排序"></a>8.1.2 折半插入排序</h3><h3 id="8-1-3-希尔排序"><a href="#8-1-3-希尔排序" class="headerlink" title="8.1.3 希尔排序"></a>8.1.3 希尔排序</h3><p><strong>1.基本概念</strong></p>
<blockquote>
<p>希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。</p>
<p>希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。</p>
<p>它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。</p>
</blockquote>
<p><strong>2.适用说明</strong></p>
<p>希尔排序时间复杂度是$O(n^{\frac{3}{2}})$，空间复杂度是$O(1)$，==只能用于顺序结构，不适用于链式结构==</p>
<p><strong>3.过程演示</strong></p>
<p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量$gap=\frac{length}{2}$，缩小增量继续以$gap=\frac{gap}{2}$的方式，这种增量选择我们可以用一个序列来表示，{$\frac{n}{2},\frac{\frac{n}{2}}{2},…,1$}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>如图所示：</p>
<p>（1）初始增量第一趟$gap=\frac{length}{2}$</p>
<p><img src="../../../images/数据结构/20210527-image-20210527091618326.png" alt="image-20210527091618326" style="zoom:80%;" /></p>
<p>（2）第二趟，增量缩小为2</p>
<p><img src="../../../images/数据结构/20210527-image-20210527091709212.png" alt="image-20210527091709212" style="zoom:80%;" /></p>
<p>（3）第三趟，增量缩小为1，得到最终结果</p>
<p><img src="../../../images/数据结构/20210527-image-20210527091738713.png" alt="image-20210527091738713" style="zoom:80%;" /></p>
<p><strong>4.算法伪码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(SqlList &amp;L, <span class="keyword">int</span> dk)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对顺序表L做一趟增量是dk的希尔排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=dk+<span class="number">1</span>;i&lt;=L.length;++i)</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i-dk].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span> &amp;&amp; L.r[<span class="number">0</span>].key&lt;L.r[j].key;j-=dk)		<span class="comment">//记录后移，直到找到插入位置</span></span><br><span class="line">                L.r[j+dk]=L.r[j];								<span class="comment">//将r[0]即原r[i]，插入到正确位置</span></span><br><span class="line">            L.r[j+dk]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> dt[],<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//按增量序列dt[0...t-1]对顺序表L作希尔排序</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;t;++k)</span><br><span class="line">        ShellInsert(L,dt[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp, gap;</span><br><span class="line">    <span class="keyword">for</span> (gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt; data[i - gap]) &#123;</span><br><span class="line">                temp = data[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i - gap; j &gt; <span class="number">-1</span> &amp;&amp; data[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                    data[j + gap] = data[j];</span><br><span class="line">                &#125;</span><br><span class="line">                data[j + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-交换排序"><a href="#8-2-交换排序" class="headerlink" title="8.2 交换排序"></a>8.2 交换排序</h2><h3 id="8-2-1-冒泡排序"><a href="#8-2-1-冒泡排序" class="headerlink" title="8.2.1 冒泡排序"></a>8.2.1 冒泡排序</h3><p><strong>1.基本概念</strong></p>
<blockquote>
<p>从前到后或者从后到前依次对比相邻两个数，如果逆序就交换。</p>
<p>特点：==稳定，适用于链表==</p>
</blockquote>
<p><strong>2.过程演示</strong></p>
<p>原始数据：<br> 3, 2, 7, 6, 8<br> 第1次循环：(最大的跑到最右边。)<br> 2, 3, 7, 6, 8 （3和2比较，2 &lt; 3，所以2和3交换位置）<br> 2, 3, 7, 6, 8 （虽然不需要交换位置：但是3和7还是需要比较一次。）<br> 2, 3, 6, 7, 8 （7和6交换位置）<br> 2, 3, 6, 7, 8 （虽然不需要交换位置：但是3和7还是需要比较一次。）</p>
<p> 经过第1次循环，此时剩下参与比较的数据：2, 3, 6, 7<br> 第2次循环：<br> 2, 3, 6, 7 (2和3比较，不需要交换位置)<br> 2, 3, 6, 7 （3和6比较，不需要交换位置）<br> 2, 3, 6, 7 (6和7比较，不需要交换位置)</p>
<p> 经过第2次循环，此时剩下参与比较的数据：2, 3, 6<br> 第3次循环：<br> 2, 3, 6 (2和3比较，不需要交换位置)<br> 2, 3, 6 （3和6比较，不需要交换位置）</p>
<p> 经过第3次循环，此时剩下参与比较的数据：2, 3<br> 第4次循环：<br> 2, 3 (2和3比较，不需要交换位置)</p>
<p><strong>3.算法代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubleSort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//是否进行交换的标志</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &lt; data[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(data[j], data[j - <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本趟遍历后没有发生交换，说明表已经有序。</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">38</span>, <span class="number">49</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    BubleSort(a, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.效率分析</strong></p>
<p><img src="../../../images/数据结构/image-20220701211121971.png" alt="image-20220701211121971"></p>
<p>最好情况：原本有序，$O(n)$</p>
<p>最坏情况：逆序，$O(n^2)$</p>
<h3 id="8-2-2-快速排序"><a href="#8-2-2-快速排序" class="headerlink" title="8.2.2 快速排序"></a>8.2.2 快速排序</h3><p><strong>1.基本概念</strong></p>
<blockquote>
<p>算法思想：在待排序表中任取一个元素pivot作为主元，将待排序表划分为两部分，使左边部分元素都小于主元，右边部分元素都大于等于主元，最终插入pivot，这是一次划分。之后重复递归两个子部分，直到每部分只有一个元素或空。</p>
<p>特点：==不稳定==</p>
</blockquote>
<p><strong>2.过程演示</strong></p>
<p><img src="../../../images/数据结构/image-20220701204947055.png" alt="image-20220701204947055"></p>
<p><strong>3.算法代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = data[low];<span class="comment">//定义第一个元素为主元</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;<span class="comment">//如果low&lt;high</span></span><br><span class="line">        <span class="comment">//右指针想左扫描，如果&gt;=主元就跳过，否则赋值给data[low]</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; data[high] &gt;= pivot)</span><br><span class="line">            --high;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">            data[low++] = data[high];</span><br><span class="line">        <span class="comment">//左指针右扫描，如果&lt;=主元就跳过，否则赋值给data[high]</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; data[low] &lt;= pivot)</span><br><span class="line">            ++low;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">            data[high--] = data[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将主元放在最终位置</span></span><br><span class="line">    data[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;<span class="comment">//返回存放主元的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = Partition(data, low, high);</span><br><span class="line">        QuickSort(data, low, pos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(data, pos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">38</span>, <span class="number">49</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    QuickSort(a, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.算法效率分析</strong></p>
<p><img src="../../../images/数据结构/image-20220701205042641.png" alt="image-20220701205042641"></p>
<p>最好情况是：每一次主元将待排序序列划分为均匀的两部分。</p>
<p>最坏的情况，每次主元划分为不均匀的部分。（原本有序，或者逆序）</p>
<p><img src="../../../images/数据结构/image-20220701205621919.png" alt="image-20220701205621919"></p>
<p>优化：①选头、中、尾三个位置的元素，去中间值为主元。②随机选一个元素作为主元。</p>
<h2 id="8-3-选择排序"><a href="#8-3-选择排序" class="headerlink" title="8.3 选择排序"></a>8.3 选择排序</h2><h3 id="8-3-1-简单选择排序"><a href="#8-3-1-简单选择排序" class="headerlink" title="8.3.1 简单选择排序"></a>8.3.1 简单选择排序</h3><p><strong>1.基本概念</strong></p>
<blockquote>
<p>算法思想：每一趟在待排序选择关键字最小的元素加入到有序序列。</p>
<p>特点：不稳定，既可以顺序表，也可以链表</p>
</blockquote>
<p><strong>2.过程演示</strong></p>
<p>   选择排序比冒泡排序的效率高</p>
<p>   高在交换位置的次数上。</p>
<p>   循环一次，然后找出参加比较的这堆数据中最小的，拿着这个最小的值和<br>   最前面的数据”交换位置”</p>
<p>   参与比较的数据：3 1 6 2 5  这一堆数据最左边下标为0<br>   第1次循环之后的结果是：<br>   1 3 6 2 5</p>
<p>   参与比较的数据：3 6 2 5   这一堆数据最左边下标为1<br>   第2次循环之后的结果是：<br>   2 6 3 5</p>
<p>   参与比较的数据：6 3 5    这一堆数据最左边下标为2<br>   第3次循环之后的结果是：<br>   6 5</p>
<p>   参与比较的数据：6 5     这一堆数据最左边下标为3<br>   第4次循环之后的结果是：<br>   5 6</p>
<p>   注意：5条数据，循环4次</p>
<p><strong>3.算法代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;<span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="keyword">int</span> min = i;<span class="comment">//记录最小元素位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j) &#123; <span class="comment">//在i..n-1中选择最小元素</span></span><br><span class="line">            <span class="keyword">if</span> (data[j] &lt; data[min])</span><br><span class="line">                min = j;<span class="comment">//更新最小元素位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != min) &#123;</span><br><span class="line">            swap(data[i],data[min]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.效率分析</strong></p>
<p><img src="../../../images/数据结构/image-20220701212338821.png" alt="image-20220701212338821"></p>
<p>时间复杂度为：$O(n^2)$</p>
<h3 id="8-3-2-树形选择排序"><a href="#8-3-2-树形选择排序" class="headerlink" title="8.3.2 树形选择排序"></a>8.3.2 树形选择排序</h3><h3 id="8-3-3-堆排序"><a href="#8-3-3-堆排序" class="headerlink" title="8.3.3 堆排序"></a>8.3.3 堆排序</h3><p><strong>1.基本概念</strong></p>
<blockquote>
<p>大根堆：根&gt;=左右孩子</p>
<p>小根堆：根&lt;=左右孩子</p>
<p>根为i，则左孩子是2i，右孩子是2i+1，父节点为i/2，i从1开始</p>
<p>算法思想：把所有非终端节点都检查一遍，看是否满足大根堆要求，如果不满足进行调整（将当前节点与更大的孩子互换</p>
<p>）。</p>
<p>特点：不稳定</p>
</blockquote>
<p><strong>2.过程演示</strong></p>
<p><strong>3.算法代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len &gt;&gt; <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;<span class="comment">//从后往前调整所有非终端节点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.调整大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];<span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//对比左右孩子，取更大的孩子</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">//如果根节点比孩子更大，就退出；否则更新</span></span><br><span class="line">        <span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序具体逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);<span class="comment">//初始建堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; --i) &#123;<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);<span class="comment">//堆顶与堆低元素互换</span></span><br><span class="line">        HeadAdjust(A, <span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">//把剩余待排序元素整理成堆。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">38</span>, <span class="number">49</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    HeapSort(a, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.效率分析</strong></p>
<p><img src="../../../images/数据结构/image-20220702211601835.png" alt="image-20220702211601835"></p>
<p><img src="../../../images/数据结构/image-20220702211703123.png" alt="image-20220702211703123"></p>
<p><img src="../../../images/数据结构/image-20220702211744851.png" alt="image-20220702211744851"></p>
<p><img src="../../../images/数据结构/image-20220702211950125.png" alt="image-20220702211950125"></p>
<p><strong>5.堆的插入删除</strong></p>
<blockquote>
<p>插入：对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。新元素就这么一路上升，知道无法上升为止。</p>
<p>删除：被删除元素用堆低元素代替，然后让钙元素不断下坠，直到无法下坠。</p>
</blockquote>
<h2 id="8-4-归并排序"><a href="#8-4-归并排序" class="headerlink" title="8.4 归并排序"></a>8.4 归并排序</h2><p><strong>1.基本概念</strong></p>
<blockquote>
<p>算法思路：把两个或多个有序的子序列合并为一个</p>
<p>特点：稳定</p>
</blockquote>
<p><strong>2.过程分析</strong></p>
<p><strong>3.算法代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        MergeSort(a, begin, mid);</span><br><span class="line">        MergeSort(a, mid + <span class="number">1</span>, end);</span><br><span class="line">        Merge(a, begin, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> helper[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        helper[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = begin;<span class="comment">//左部分开始指针</span></span><br><span class="line">    <span class="keyword">int</span> right = mid + <span class="number">1</span>;<span class="comment">//右部分开始指针</span></span><br><span class="line">    <span class="keyword">int</span> current = begin;<span class="comment">//索引下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helper[left] &lt;= helper[right]) &#123;</span><br><span class="line">            a[current++] = helper[left++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[current++] = helper[right++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右指针比对完了，但是左边还没有放入</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">        a[current++] = helper[left++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.效率分析</strong></p>
<p><img src="../../../images/数据结构/image-20220702222731538.png" alt="image-20220702222731538"></p>
<p>时间复杂度：$O(nlogn)$，空间复杂度$O(n)$</p>
<h2 id="8-5-基数排序"><a href="#8-5-基数排序" class="headerlink" title="8.5 基数排序"></a>8.5 基数排序</h2><p><strong>1.基本概念</strong></p>
<blockquote>
<p>特点：链式存储，稳定</p>
</blockquote>
<p><strong>2.过程分析</strong></p>
<p>以个位分配：</p>
<p><img src="../../../images/数据结构/image-20220703201839995.png" alt="image-20220703201839995"></p>
<p><img src="../../../images/数据结构/image-20220703201856707.png" alt="image-20220703201856707"></p>
<p>以十位分配：</p>
<p><img src="../../../images/数据结构/image-20220703202009127.png" alt="image-20220703202009127"></p>
<p>以百位分配：</p>
<p><img src="../../../images/数据结构/image-20220703202107684.png" alt="image-20220703202107684"></p>
<p><strong>3.算法代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队列得列头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p><strong>4.效率分析</strong></p>
<p><strong>5.基数排序的应用</strong></p>
<p><img src="../../../images/数据结构/image-20220703204405241.png" alt="image-20220703204405241"></p>
<p>基数排序擅长解决：</p>
<ul>
<li>数据元素的关键字可以方便的拆分为d组，且d较小</li>
<li>每组关键字的取值范围不大，即r较小</li>
<li>数据元素个数n较大</li>
</ul>
<h2 id="8-6-外部排序"><a href="#8-6-外部排序" class="headerlink" title="8.6 外部排序"></a>8.6 外部排序</h2><p><strong>1.基本概念</strong></p>
<blockquote>
<p>外部排序原理：数据元素太多，无法一次全部读入内存进行排序。</p>
</blockquote>
<p><strong>2.过程分析</strong></p>
<p><img src="../../../images/数据结构/image-20220703205953193.png" alt="image-20220703205953193"></p>
<p><img src="../../../images/数据结构/image-20220703210139247.png" alt="image-20220703210139247"></p>
<p><img src="../../../images/数据结构/image-20220703211238539.png" alt="image-20220703211238539"></p>
<p><img src="../../../images/数据结构/image-20220703211311373.png" alt="image-20220703211311373"></p>
<p><strong>3.算法代码</strong></p>
<p><strong>4.效率分析</strong></p>
<p><img src="../../../images/数据结构/image-20220703212400232.png" alt="image-20220703212400232"></p>
<p>如何优化？</p>
<p>​    可以看到，影响时间速率的是归并的趟数。上面使用的是2路归并，可以进行多路归并来缩减时间，如果采用4路归并，读写磁盘次数=32+32*2=96</p>
<p>重要结论：采用多路归并可以减少归并趟数，从而减少磁盘IO次数</p>
<p>==$对r个初始归并段，做k路归并，则归并树可用k叉树表示，若树高为h，则归并趟数S=h-1=\left \lceil{log_kr} \right \rceil$==</p>
<h3 id="8-6-1-败者树"><a href="#8-6-1-败者树" class="headerlink" title="8.6.1 败者树"></a>8.6.1 败者树</h3><p><strong>1.基本概念</strong></p>
<blockquote>
<p>可以看做一颗完全二叉树（多了一颗头头）。k个叶节点分别是当前参加比较的元素，非叶子结点迎来记忆左右子树的失败者，而让胜利者网上继续比较，一直到根节点。</p>
</blockquote>
<p><strong>2.败者树在多路归并的应用</strong></p>
<p>叶子结点相比较，选出最小的，只不过，存储的不是元素，而是这个元素来自哪个归并段。</p>
<p><img src="../../../images/数据结构/image-20220703214449902.png" alt="image-20220703214449902"></p>
<p><img src="../../../images/数据结构/image-20220703214811189.png" alt="image-20220703214811189"></p>
<h3 id="8-6-2-置换-选择排序"><a href="#8-6-2-置换-选择排序" class="headerlink" title="8.6.2 置换-选择排序"></a>8.6.2 置换-选择排序</h3><p><img src="../../../images/数据结构/image-20220703215954764.png" alt="image-20220703215954764"></p>
<p><img src="../../../images/数据结构/image-20220703220015875.png" alt="image-20220703220015875"></p>
<p><img src="../../../images/数据结构/image-20220703220027885.png" alt="image-20220703220027885"></p>
<p><strong>算法步骤</strong></p>
<blockquote>
<p>1）从FI输入w个记录到工作区WA。</p>
<p>2）从WA中选出其中关键字取最小值，记录为MINIMAX。</p>
<p>3）将MINIMAX记录输出到FO中去。</p>
<p>4）若FI不为空，则从FI输入下一个记录到WA中。</p>
<p>5）从WA中所有 关键字比MINIMAX记录的关键字大的记录中 选出 最小关键字记录，作为MINIMAX记录。</p>
<p>6）重复3-5，直到WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</p>
<p>7）重复2-6，直到WA为空。</p>
</blockquote>
<h3 id="8-6-3-最佳归并树"><a href="#8-6-3-最佳归并树" class="headerlink" title="8.6.3 最佳归并树"></a>8.6.3 最佳归并树</h3><p>重要结论：</p>
<p>​                                                $归并过冲中的磁盘I/O次数=归并树WPL*2$</p>
<p>构造哈夫曼树优化：</p>
<p><img src="../../../images/数据结构/image-20220703222317866.png" alt="img"></p>
<p>对于三路以上需要添加虚段：</p>
<p><img src="../../../images/数据结构/image-20220703222542602.png" alt="image-20220703222542602"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h3 id="小知识：函数参数是否带“-amp-”的区别"><a href="#小知识：函数参数是否带“-amp-”的区别" class="headerlink" title="小知识：函数参数是否带“&amp;”的区别"></a>小知识：函数参数是否带“&amp;”的区别</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1024</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在函数中的x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1024</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在函数中的x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未经过函数的x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    test1(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;经过函数的x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未经过函数的x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    test2(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;经过函数的x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">未经过函数的x = <span class="number">666</span></span><br><span class="line">在函数中的x = <span class="number">1024</span></span><br><span class="line">经过函数的x = <span class="number">666</span></span><br><span class="line">------------------</span><br><span class="line">未经过函数的x = <span class="number">666</span></span><br><span class="line">在函数中的x = <span class="number">1024</span></span><br><span class="line">经过函数的x = <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<p>可以看到添加“&amp;”之后，x的值从666修改为了1024。</p>
<p>实际上，主函数中定义的x和test函数中的参数x并不是同一个，在虚拟内存中，他们的地址是不同的。而&amp;叫做引用符，它可以引用主函数中x的地址，这样就可以对主函数中的x进行修改。所以函数需要修改原变量时，需要给该参数添加&amp;。</p>
<h3 id="各个数据类型的定义结构体"><a href="#各个数据类型的定义结构体" class="headerlink" title="各个数据类型的定义结构体"></a>各个数据类型的定义结构体</h3><p><img src="../../../images/数据结构/QQ截图20220919102243.jpg" alt="QQ截图20220919102243"></p>
<h2 id="1-顺序表的基本操作"><a href="#1-顺序表的基本操作" class="headerlink" title="1 顺序表的基本操作"></a>1 顺序表的基本操作</h2><p><a href="#2.3.2 顺序表的基本操作">点击我回到原位置</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data; <span class="comment">//定义一个名为data的长度不确定的数组，也叫“动态数组”</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">//记录当前顺序表的长度</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">//记录顺序表的存储容量</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造一个空的顺序表，动态申请存储空间</span></span><br><span class="line">    L.data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(Size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//如果申请失败，作出提示并直接退出程序</span></span><br><span class="line">    <span class="keyword">if</span> (L.data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空表的长度初始化为0</span></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//空表的初始存储空间为Size</span></span><br><span class="line">    L.size = Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数，其中，e为插入的元素，i为插入到顺序表的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; L.length + <span class="number">1</span> || i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置有问题\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == L.size) &#123;</span><br><span class="line">        L.data = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(L.data, (L.size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (L.data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;存储分配失败\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L.size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入操作，需要将自插入位置之后的所有元素全部后移一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后移完成后，直接插入元素</span></span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; L.length || i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;被删除元素的位置有误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locateElem</span><span class="params">(SqList L, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listAmend</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> e, <span class="keyword">int</span> newElem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add = locateElem(L, e);</span><br><span class="line">    <span class="keyword">if</span> (add == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表中没有找到目标元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[add - <span class="number">1</span>] = newElem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序表中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, add;</span><br><span class="line">    SqList sl = &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    initList(sl);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Size; i++) &#123;</span><br><span class="line">        sl.data[i - <span class="number">1</span>] = i;</span><br><span class="line">        sl.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原顺序表：\n&quot;</span>);</span><br><span class="line">    showList(sl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除元素2:\n&quot;</span>);</span><br><span class="line">    listDelete(sl, <span class="number">2</span>);</span><br><span class="line">    showList(sl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在第2的位置插入元素5:\n&quot;</span>);</span><br><span class="line">    listInsert(sl, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    showList(sl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;查找元素3的位置:\n&quot;</span>);</span><br><span class="line">    add = locateElem(sl, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;将元素3改为6:\n&quot;</span>);</span><br><span class="line">    listAmend(sl, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">    showList(sl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-链表的基本操作"><a href="#2-链表的基本操作" class="headerlink" title="2 链表的基本操作"></a>2 链表的基本操作</h2><h3 id="2-1-单链表的基本操作"><a href="#2-1-单链表的基本操作" class="headerlink" title="2.1 单链表的基本操作"></a>2.1 单链表的基本操作</h3><p><a href="#2.4.1 单链表的基本概念">点我回到原来位置</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义结点类型结构体，有一个data域和一个next域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，生成带有头结点的单链表</span></span><br><span class="line"><span class="comment"> * @param L 引用类型，头指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L) &#123;   <span class="comment">//内存分配成功</span></span><br><span class="line">        L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插法建立单链表</span></span><br><span class="line"><span class="comment"> * @param L 引用类型的头指针</span></span><br><span class="line"><span class="comment"> * @param n 表示需要插入的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadInsert_LinkList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LNode *s;   <span class="comment">//辅助指针s，用于指向新申请的结点空间，并将输入的数据存入s-&gt;data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//申请新结点空间</span></span><br><span class="line">        <span class="keyword">if</span> (s)  <span class="comment">//内存分配成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;data);  <span class="comment">//输入需要插入的值</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 头插法的关键步骤：</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            s-&gt;next = L-&gt;next;  <span class="comment">//让s的next已知的L的next（最开始为NULL）</span></span><br><span class="line">            L-&gt;next = s;        <span class="comment">//再让头指针L的next指向新插入的结点s</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插法建立单链表</span></span><br><span class="line"><span class="comment"> * @param L 引用类型的头指针</span></span><br><span class="line"><span class="comment"> * @param n 需要插入的元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RailInsert_LinkList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LNode *s, *r;  <span class="comment">//s用于指向新申请的节点空间，r用于始终指向尾结点</span></span><br><span class="line">    r = L;   <span class="comment">//r初始指向头结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span> (s) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;data);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 尾插法的关键步骤</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            r-&gt;next = s;  <span class="comment">//直接让r的next指向新结点s</span></span><br><span class="line">            r = s;        <span class="comment">//再让r重新指向当前的尾结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//最后，将r的next置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在单链表中插入一个元素</span></span><br><span class="line"><span class="comment"> * @param L        单链表的头指针，代表单链表，使用引用型</span></span><br><span class="line"><span class="comment"> * @param location 在第location个位置插入</span></span><br><span class="line"><span class="comment"> * @param elem     插入的元素值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertElem_LinkList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> location, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    LNode *p, *s;  <span class="comment">//p用于遍历单链表，s用于指向新生成的结点空间，并存储插入的数据</span></span><br><span class="line">    p = L;  <span class="comment">//p初始指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">//计数，帮助找到要插入的第i个位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    while (p != NULL &amp;&amp; j &lt; location) &#123;</span></span><br><span class="line"><span class="comment">        p = p-&gt;next;</span></span><br><span class="line"><span class="comment">        ++j;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (!p || j &gt; location)  //插入的位置小于1或者大于表长+1</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; location; j++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">        s-&gt;data = elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        插入的关键步骤：顺序不能颠倒</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s-&gt;next = p-&gt;next;  <span class="comment">//先把第i-1个位置的next给到s的next</span></span><br><span class="line">        p-&gt;next = s;        <span class="comment">//再把s给到第i-1个位置的next，即给到第i个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序输出单链表中元素的值</span></span><br><span class="line"><span class="comment"> * @param L 单链表的头指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_LinkList</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主函数</span></span><br><span class="line"><span class="comment"> * @return 1，结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    InitLinkList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    // 头插法建立单链表</span></span><br><span class="line"><span class="comment">    printf(&quot;请输入元素个数：&quot;);</span></span><br><span class="line"><span class="comment">    fflush(stdout);</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d&quot;, &amp;n);</span></span><br><span class="line"><span class="comment">    HeadInsert_LinkList(L, n);</span></span><br><span class="line"><span class="comment">    printf(&quot;链表为：&quot;);</span></span><br><span class="line"><span class="comment">    Print_LinkList(L);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 尾插法建立单链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入元素个数：&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    RailInsert_LinkList(L, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表为：&quot;</span>);</span><br><span class="line">    Print_LinkList(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">int</span> i, elem;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的位置和元素值：&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;i, &amp;elem);</span><br><span class="line">    InsertElem_LinkList(L, i, elem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;添加数据%d后的链表：&quot;</span>, elem);</span><br><span class="line">    Print_LinkList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-栈的基本操作"><a href="#3-栈的基本操作" class="headerlink" title="3 栈的基本操作"></a>3 栈的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//定义一个栈</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *base;</span><br><span class="line">    ElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InintStak</span><span class="params">(SqStack &amp;s)</span><span class="comment">//初始化一个顺序栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.base = <span class="keyword">new</span> ElemType[MAXSIZE];<span class="comment">//给栈一个分配一个数组，这个栈的基地址为数组首地址</span></span><br><span class="line">    <span class="keyword">if</span> (!s.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈不存在基地址，没有分配成功</span></span><br><span class="line">    s.top = s.base;<span class="comment">//分配成功，top=base，栈S为空表</span></span><br><span class="line">    s.stacksize = MAXSIZE;<span class="comment">//栈的最大空间就是数组元素个数，数组几个数，栈就几个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateStack</span><span class="params">(SqStack &amp;s)</span><span class="comment">//创建一个</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;<span class="comment">//n为输入元素的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入元素：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; MAXSIZE; m++) &#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *s.top = n;<span class="comment">//*S.top的值是n</span></span><br><span class="line">        s.top++;<span class="comment">//头节点往上移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushStack</span><span class="params">(SqStack &amp;s, ElemType e)</span><span class="comment">//将值e入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *s.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopStack</span><span class="params">(SqStack &amp;s, ElemType &amp;e)</span><span class="comment">//出栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top == s.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = *--s.top;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetlengthStack</span><span class="params">(SqStack s, ElemType &amp;a)</span><span class="comment">//获取栈的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top - s.base == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = s.top - s.base;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈长为:%d&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DisplayStack</span><span class="params">(SqStack s)</span><span class="comment">//打印栈的内容,读栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType *i;</span><br><span class="line">    i = s.top;<span class="comment">//采用后进先出规则</span></span><br><span class="line">    <span class="keyword">if</span> (s.top == s.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; s.base)<span class="comment">//后进先出，从top指针的元素开始出栈</span></span><br><span class="line">    &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e, a, b;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InintStak(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建一个顺序栈\n&quot;</span>);</span><br><span class="line">    CreateStack(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印这个顺序栈：&quot;</span>);</span><br><span class="line">    DisplayStack(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进行入栈操作\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你要入栈的数是：&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">    pushStack(S, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入栈后，这时的顺序栈为：&quot;</span>);</span><br><span class="line">    DisplayStack(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进行出栈操作\n&quot;</span>);</span><br><span class="line">    PopStack(S, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出栈后，这时的顺序栈为：&quot;</span>);</span><br><span class="line">    DisplayStack(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时顺序栈的长度为：&quot;</span>);</span><br><span class="line">    GetlengthStack(S, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-共享栈的基本操作"><a href="#4-共享栈的基本操作" class="headerlink" title="4 共享栈的基本操作"></a>4 共享栈的基本操作</h2><p><a href="#3.2.3 共享栈：解决栈大小不可改变">点我回到原来位置</a></p>
<p><img src="../../../images/数据结构/image-20220815211558114.png" alt="image-20220815211558114" style="zoom:50%;" /></p>
<p><img src="../../../images/数据结构/image-20220815184309588.png" alt="image-20220815184309588"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top[<span class="number">2</span>];<span class="comment">//top[0]是s0的栈顶，top[1]是s1的栈顶</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initShStack</span><span class="params">(ShStack &amp;sh)</span></span>&#123;</span><br><span class="line">    sh.top[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    sh.top[<span class="number">1</span>]=max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="keyword">int</span> push(ShStack &amp;sh, <span class="keyword">int</span> stNo, <span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sh.top[<span class="number">0</span>] + <span class="number">1</span> &lt; sh.top[<span class="number">1</span>])&#123;<span class="comment">//栈不满</span></span><br><span class="line">        <span class="keyword">if</span>(stNo==<span class="number">0</span>)&#123;<span class="comment">//元素入s0</span></span><br><span class="line">            ++sh.top[<span class="number">0</span>];</span><br><span class="line">            sh.elem[sh.top[<span class="number">0</span>]]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stNo==<span class="number">1</span>)&#123;<span class="comment">//元素入s1</span></span><br><span class="line">            --sh.top[<span class="number">1</span>];</span><br><span class="line">            sh.elem[sh.top[<span class="number">1</span>]]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//栈编号误，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满后元素不能入栈，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(ShStack &amp;sh, <span class="keyword">int</span> stNo, <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stNo==<span class="number">0</span>)&#123;<span class="comment">//元素出s0</span></span><br><span class="line">        <span class="keyword">if</span>(sh.top[<span class="number">0</span>] != <span class="number">-1</span>)&#123;<span class="comment">//s0不是空栈</span></span><br><span class="line">            sh.elem[sh.top[<span class="number">0</span>]]=x;</span><br><span class="line">            --sh.top[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//s0空栈，出栈失败</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stNo==<span class="number">1</span>)&#123;<span class="comment">//元素出s1</span></span><br><span class="line">        <span class="keyword">if</span>(sh.top[<span class="number">1</span>] != maxSize)&#123;</span><br><span class="line">            sh.elem[sh.top[<span class="number">1</span>]]=x;</span><br><span class="line">            ++sh.top[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//s1空，初战失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//栈编号误，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="qnjy 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="qnjy 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/9af0416b.html" rel="prev" title="JPA框架学习">
                  <i class="fa fa-chevron-left"></i> JPA框架学习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/282276cb.html" rel="next" title="BUUCTF_Web">
                  BUUCTF_Web <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qnjy</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  




  <script src="/js/local-search.js"></script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  





</body>
</html>
