<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qnjy.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="第一章 绪论1.1 数据结构的基本概念1.2 算法的基本概念1.2.1 时间复杂度　　事前预估算法时间开销T(n)与问题规模n的关系。分析算法操作的执行次数x和问题模型n的关系x&#x3D;f(n)。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://qnjy.github.io/post/79666db.html">
<meta property="og:site_name" content="qnjy&#39;s blog">
<meta property="og:description" content="第一章 绪论1.1 数据结构的基本概念1.2 算法的基本概念1.2.1 时间复杂度　　事前预估算法时间开销T(n)与问题规模n的关系。分析算法操作的执行次数x和问题模型n的关系x&#x3D;f(n)。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/03/24/6boW7T.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/03/24/6bo3fH.jpg">
<meta property="og:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1257338926,4293580614&fm=11&gp=0.jpg">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/20/164b52876a6a2c70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/20/164b528765cf96a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/7/20/164b52876589ba10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1620868011-image-20210513090651272.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1620868285-image-20210513091125197.png">
<meta property="og:image" content="http://c.biancheng.net/uploads/allimg/190426/1I33AU8-0.gif">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/18/1718dca693468461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/18/1718dca6c2c29574?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/18/1718dca6c2b715c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/18/1718dca6c81237bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617873987-image-20210408172627868.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617874886-image-20210408174126047.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617875446-image-20210408175046697.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786835-image-20210407171355733.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617844641-image-20210408091721508.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876251-image-20210408180411607.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876268-image-20210408180428251.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876291-image-20210408180451411.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876532-image-20210408180852817.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876541-image-20210408180901861.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786182-image-20210407170302561.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786227-image-20210407170347593.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786252-image-20210407170412791.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617788435-image-20210407174035666.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053575-image-20210422090614930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053611-image-20210422090651292.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053789-image-20210422090949365.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053809-image-20210422091009192.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618393158-image-20210414173918248.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618445484-image-20210415081124676.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618445972-image-20210415081932478.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618446095-image-20210415082134980.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618446122-image-20210415082202662.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619055375-image-20210422093615176.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210603-image-20210603095305745.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210603-image-20210603093907428.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618999001-image-20210421175641281.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618998974-image-20210421175614149.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618999143-image-20210421175903730.png ">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618999151-image-20210421175911065.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599276-image-20210428164116694.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599384-image-20210428164304480.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599429-image-20210428164349664.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599481-image-20210428164441752.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599589-image-20210428164628941.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599660-image-20210428164740239.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619600884-image-20210428170804280.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619601939-image-20210428172539618.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619655052-image-20210429081052350.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210602-image-20210602230209346.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210602-image-20210602230310978.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210526-image-20210526175341516.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527080726469.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081029408.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081355420.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081640790.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081706164.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081850609.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081924315.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081948695.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082030489.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082102010.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082126473.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082230583.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082324312.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082352452.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527094036260.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527091618326.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527091709212.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527091738713.png">
<meta property="article:published_time" content="2021-03-14T02:18:29.000Z">
<meta property="article:modified_time" content="2022-01-03T11:04:18.507Z">
<meta property="article:author" content="qnjy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/03/24/6boW7T.jpg">


<link rel="canonical" href="https://qnjy.github.io/post/79666db.html">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构 | qnjy's blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">qnjy's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">方向不对，努力白费</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="nav-text">第一章 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1 数据结构的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1.2 算法的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.2.1 时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.2.2 空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">第二章 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 线性表的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1.1 数学定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">2.1.2 线性表的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">2.2 线性表的存储方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">2.3 顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2.3.1 顺序表的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-text">2.3.2 顺序表的插入元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">2.3.3 顺序表的删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="nav-text">2.3.4 顺序表的查找元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9B%B4%E6%94%B9%E5%85%83%E7%B4%A0"><span class="nav-text">2.3.5 顺序表的更改元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">2.4 单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E8%8E%B7%E5%8F%96%E9%93%BE%E8%A1%A8%E7%AC%ACi%E4%B8%AA%E6%95%B0%E6%8D%AE"><span class="nav-text">2.4.1 获取链表第i个数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">2.5 双向链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">第三章 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88"><span class="nav-text">3.1 什么是栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">3.2 顺序栈及基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">3.2.1 顺序栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">3.2.2 顺序栈的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E9%93%BE%E6%A0%88%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">3.3 链栈及基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E9%93%BE%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">3.3.1 链栈的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97"><span class="nav-text">3.4 什么是队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">3.4.1 队列的顺序存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">3.4.2 队列的链式存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">第四章 串、数组和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E6%95%B0%E7%BB%84"><span class="nav-text">4.4 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">4.4.1 数组的类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">4.4.2 数组的顺序存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">4.4.3 特殊矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">第五章 树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1 树和二叉树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1.1 树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">5.1.2 树的基本术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1.3 二叉树的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.2 二叉树的性质和存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">5.2.1 二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.2.2 二叉树的存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.3 遍历二叉树和线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-text">5.3.1 遍历二叉树及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%BA%94%E7%94%A8"><span class="nav-text">二叉树的遍历应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.3.2 线索二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97"><span class="nav-text">5.4 树与森林</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.4.1 树的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">5.4.2 森林和二叉树的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-3-%E6%A3%AE%E6%9E%97%E5%92%8C%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">5.4.3 森林和树的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-text">5.5 哈夫曼树及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">5.5.1 哈夫曼树的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="nav-text">5.5.2 哈夫曼树的构造算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE"><span class="nav-text">第六章 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">6.1 图的定义和基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">6.1.1 图的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">6.1.2 图的基本术语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.2 图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-text">6.2.1 邻接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.2.2  链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">6.3 图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">6.3.1 深度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">6.3.2 广度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">6.4 图的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="nav-text">第七章 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">7.1 查找的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2 线性表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2.1 顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2.2 折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-text">7.2.3 分块查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">7.3 树表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-text">7.3.1 二叉排序树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">7.3.2 平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-B-%E6%A0%91"><span class="nav-text">7.3.3 B-树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="nav-text">第八章 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1.1 直接插入方法排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1.2 折半插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1.3 希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">8.2.1 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">8.2.2 快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3.1 简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-%E6%A0%91%E5%BD%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3.2 树形选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3.3 堆排序</span></a></li></ol></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="qnjy"
      src="/images/xigua.jpg">
  <p class="site-author-name" itemprop="name">qnjy</p>
  <div class="site-description" itemprop="description">宁静以致远</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qnjy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qnjy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:877900490@qq.com" title="E-Mail → mailto:877900490@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>

    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qnjy.github.io/post/79666db.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/xigua.jpg">
      <meta itemprop="name" content="qnjy">
      <meta itemprop="description" content="宁静以致远">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qnjy's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 10:18:29" itemprop="dateCreated datePublished" datetime="2021-03-14T10:18:29+08:00">2021-03-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-03 19:04:18" itemprop="dateModified" datetime="2022-01-03T19:04:18+08:00">2022-01-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h2><h2 id="1-2-算法的基本概念"><a href="#1-2-算法的基本概念" class="headerlink" title="1.2 算法的基本概念"></a>1.2 算法的基本概念</h2><h3 id="1-2-1-时间复杂度"><a href="#1-2-1-时间复杂度" class="headerlink" title="1.2.1 时间复杂度"></a>1.2.1 时间复杂度</h3><p>　　事前预估算法时间开销T(n)与问题规模n的关系。分析算法操作的执行次数x和问题模型n的关系x=f(n)。<span id="more"></span></p>
<p><strong>常见数量级关系</strong>：（常对幂指阶）</p>
<script type="math/tex; mode=display">
O(1)<O(\log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6boW7T"><img src="https://z3.ax1x.com/2021/03/24/6boW7T.jpg" alt="6boW7T.jpg" style="zoom:80%;" /></a></p>
<h3 id="1-2-2-空间复杂度"><a href="#1-2-2-空间复杂度" class="headerlink" title="1.2.2 空间复杂度"></a>1.2.2 空间复杂度</h3><p>　　无论问题规模怎么变，算法运行所需的内存空间都是固定的常量。</p>
<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的基本概念"><a href="#2-1-线性表的基本概念" class="headerlink" title="2.1 线性表的基本概念"></a>2.1 线性表的基本概念</h2><p>　　由<font color="ff0000">零个或多个</font>数据元素组成的<font color="ff0000">有序</font>序列。 特性：有序，类型相同，有限。</p>
<h3 id="2-1-1-数学定义"><a href="#2-1-1-数学定义" class="headerlink" title="2.1.1 数学定义"></a>2.1.1 数学定义</h3><p>　　线性表是具有相同类型的n(n≥0)个数据元素的有限序列（a1,a2,a3,…,an-1,an），ai是表项，n是表长度。存在前驱后继。</p>
<h3 id="2-1-2-线性表的操作"><a href="#2-1-2-线性表的操作" class="headerlink" title="2.1.2 线性表的操作"></a>2.1.2 线性表的操作</h3><ul>
<li>创建线性表</li>
<li>销毁线性表</li>
<li>清空线性表</li>
<li>将元素插入线性表</li>
<li>将元素从线性表中删除</li>
<li>获取线性表中某个位置的元素</li>
<li>获取线性表的长度</li>
</ul>
<p>线性表的抽象数据类型定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ADT线性表（List）</span><br><span class="line">    </span><br><span class="line">Data</span><br><span class="line">　　线性表的数据对象集合为&#123;a1,a2,a3,...,an<span class="number">-1</span>,an&#125;，其中，除第一个元素a1外，每个元素有且只有一个直接前驱元素，直接后继元素同理，数据元素之间的关系是一一对应的。</span><br><span class="line">    </span><br><span class="line">Operation（操作）</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，建立一个空的线性表L</span></span><br><span class="line">InitList(*L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若线性表为空，返回true，否则返回false</span></span><br><span class="line">ListEmpty(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将线性表清空</span></span><br><span class="line">ClearList(*L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将线性表L中的第i个位置的元素返回给e</span></span><br><span class="line">GetElem(L,i,*e);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，否则返回0表示失败</span></span><br><span class="line">LocateElem(L,e)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表L中的第i个位置插入新元素e</span></span><br><span class="line">ListInsert(*L,i,e);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除线性表L中的第i个位置元素，并用e返回其值</span></span><br><span class="line">ListDelete(*L,i,*e);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回线性表L的元素个数</span></span><br><span class="line">ListLength(L);;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line">DestroyList(*L);</span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h2 id="2-2-线性表的存储方式"><a href="#2-2-线性表的存储方式" class="headerlink" title="2.2 线性表的存储方式"></a>2.2 线性表的存储方式</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6bo3fH"><img src="https://z3.ax1x.com/2021/03/24/6bo3fH.jpg" alt="6bo3fH.jpg" style="zoom:67%;" /></a></p>
<p>如上图，线性表的存储细分以下两种：</p>
<p>1.将所有数据一次存储在连续的整块屋里空间中，叫做<font color="#008000">顺序存储结构</font>；</p>
<p>2.数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，<font color="#008000">链式存储结构</font>。</p>
<h2 id="2-3-顺序表"><a href="#2-3-顺序表" class="headerlink" title="2.3 顺序表"></a>2.3 顺序表</h2><p>　　顺序表不仅存在“一对一”的数据关系，对数据的物理存储结构也有要求。<font color="#b22222">顺序表存储结构时，会提前申请一整块足够大小的屋里空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝细缝</font>。</p>
<h3 id="2-3-1-顺序表的初始化"><a href="#2-3-1-顺序表的初始化" class="headerlink" title="2.3.1 顺序表的初始化"></a>2.3.1 顺序表的初始化</h3><p>　　　顺序表需要实时记录一下两项数据：</p>
<p>1.顺序表申请的存储容量；</p>
<p>2.顺序表的长度，也就是表中存储数据元素的个数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度</span><br></pre></td></tr></table></figure>
<p>因此，需要自定义顺序表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *head;<span class="comment">//声明了一个名为head的长度不确定的数组</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//记录当前顺序表的长度</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//记录顺序表分配的存储容量</span></span><br><span class="line">&#125;table;</span><br></pre></td></tr></table></figure>
<p>注意：head是未初始化的动态数组。</p>
<p>初步建立一个顺序表，需要如下工作：</p>
<ul>
<li>给head动态数据申请足够大小的物理空间</li>
<li>给size和length赋初始值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size 5;<span class="comment">//对Size进行宏定义，表示顺序表申请空间的大小</span></span></span><br><span class="line"><span class="function">table <span class="title">InitTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    table t;</span><br><span class="line">    t.head = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Size *<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//构造空的顺序表，动态申请存储空间</span></span><br><span class="line">    <span class="keyword">if</span>(!t.head)&#123;<span class="comment">//申请失败，作为提示直接退出程序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t.length = <span class="number">0</span>;<span class="comment">//空表的长度初始化为0</span></span><br><span class="line">    t.size = Size;<span class="comment">//空表的初始化存储空间为Size</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-顺序表的插入元素"><a href="#2-3-2-顺序表的插入元素" class="headerlink" title="2.3.2 顺序表的插入元素"></a>2.3.2 顺序表的插入元素</h3><ul>
<li>插入位置不合理，抛出异常</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始条件：顺序线性表L已存在，1&lt;=i&lt;=ListLength(L).</span></span><br><span class="line"><span class="comment">// 操作结果：在L中第i个位置之前插入新的数据元素e，L长度+1</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(List *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length == MAXSIZE) <span class="comment">//顺序线性表已经满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>) <span class="comment">//当i不在范围内时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= L-&gt;length) <span class="comment">//若插入数据位置不在表尾，i=length+1就是在表尾，直接添加就可以</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将要插入位置后数据元素向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (k = L-&gt;length - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[k + <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">//将新元素插入</span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-顺序表的删除元素"><a href="#2-3-3-顺序表的删除元素" class="headerlink" title="2.3.3 顺序表的删除元素"></a>2.3.3 顺序表的删除元素</h3><ul>
<li>删除位置不合理，抛出异常</li>
<li>取出删除元素</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将他们向前移动一个位置</li>
<li>表长-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(List *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (k = i; k &lt; L-&gt;length; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[k - <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-顺序表的查找元素"><a href="#2-3-4-顺序表的查找元素" class="headerlink" title="2.3.4 顺序表的查找元素"></a>2.3.4 顺序表的查找元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status是函数的类型，其值是函数结果状态代码，如OK等。</span></span><br><span class="line"><span class="comment">// 初始条件：顺序线性表L已存在， 1 &lt;= i &lt;= ListLength(L)</span></span><br><span class="line"><span class="comment">// 操作结果：用e返回L中第i个数据元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(List L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-顺序表的更改元素"><a href="#2-3-5-顺序表的更改元素" class="headerlink" title="2.3.5 顺序表的更改元素"></a>2.3.5 顺序表的更改元素</h3><h2 id="2-4-单链表"><a href="#2-4-单链表" class="headerlink" title="2.4 单链表"></a>2.4 单链表</h2><h3 id="2-4-1-获取链表第i个数据"><a href="#2-4-1-获取链表第i个数据" class="headerlink" title="2.4.1 获取链表第i个数据"></a>2.4.1 获取链表第i个数据</h3><ul>
<li>声明一个节点p指向链表第一个节点，初始化j从1开始</li>
<li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一节点，j+1</li>
<li>若到链表末尾p为空，则说明第i个元素不存在</li>
<li>否则查找成功，返回节点p的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-5-双向链表"><a href="#2-5-双向链表" class="headerlink" title="2.5 双向链表"></a>2.5 双向链表</h2><h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1-什么是栈"><a href="#3-1-什么是栈" class="headerlink" title="3.1 什么是栈"></a>3.1 什么是栈</h2><p>　　栈就是一种只能从表的一段存储数据且遵循“先进后出”原则的线性存储结构。压栈（push），弹栈（pop）。</p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1257338926,4293580614&fm=11&gp=0.jpg" alt="123" style="zoom: 50%;" /></p>
<p>栈遵循<font color="ff000">先进后出</font>，栈存储结构的实现有以下两种方式：</p>
<ul>
<li>顺序栈</li>
<li>链栈</li>
</ul>
<h2 id="3-2-顺序栈及基本操作"><a href="#3-2-顺序栈及基本操作" class="headerlink" title="3.2 顺序栈及基本操作"></a>3.2 顺序栈及基本操作</h2><h3 id="3-2-1-顺序栈的定义"><a href="#3-2-1-顺序栈的定义" class="headerlink" title="3.2.1 顺序栈的定义"></a>3.2.1 顺序栈的定义</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/20/164b52876a6a2c70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="11" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> data[maxsize];    <span class="comment">//定义一个数组大小为maxsize的数组，用来存放栈中数据元素    </span></span><br><span class="line">    <span class="keyword">int</span> top;              <span class="comment">//栈顶指针                 </span></span><br><span class="line">&#125;SqStack;				  <span class="comment">//顺序栈定义</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-顺序栈的操作"><a href="#3-2-2-顺序栈的操作" class="headerlink" title="3.2.2 顺序栈的操作"></a>3.2.2 顺序栈的操作</h3><p>可以参考<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/170.html">顺序栈的操作C语言版</a></p>
<p>对于顺序栈，一共有4个要素，包括两个特殊状态和两个操作</p>
<p>特殊状态：</p>
<p>1）栈空状态：<code>st.top == -1</code>，也有的用<code>st.top = 0</code>表示，这时候栈顶位置为0；</p>
<p>2）栈满状态：<code>st.top == maxsize - 1</code>表示栈满，maxsize是栈中最大元素个数，maxsize-1为栈满时栈顶元素在数组中的位置，因为数组位置是从0开始的。</p>
<p>操作：</p>
<p>进栈和出栈</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/20/164b528765cf96a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1234" style="zoom: 67%;" /></p>
<p>以下是数组实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*源代码*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType <span class="built_in">stack</span>[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;  </span><br><span class="line">&#125;SeqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化栈,把栈初始化为空，把栈顶指针置为-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SeqStack * s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判空操作，当栈顶指针为top 为-1，栈为空*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(SeqStack s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈操作，栈顶指针top++，然后将data值压入栈中*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackPush</span><span class="params">(SeqStack* s, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，不能入栈！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;top++;</span><br><span class="line">        s-&gt;<span class="built_in">stack</span>[s-&gt;top] = data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取栈顶元素，将栈顶元素输出*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackGetTop</span><span class="params">(SeqStack s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.<span class="built_in">stack</span>[s.top]);</span><br><span class="line">        s.top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输入要入栈的元素以 -1 作为结束标志*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInput</span><span class="params">(SeqStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    <span class="keyword">while</span> (data != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        StackPush(s, data);</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印栈中元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(SeqStack s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = s.top; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, s.<span class="built_in">stack</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*出栈操作，将栈顶指针top-- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(SeqStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回栈的长度,栈的长度就是栈中元素的个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SeqStack s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     s.top + <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.top + <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清空栈，清空栈与初始化栈的操作一样，只需将栈顶指针置-1即可*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackClear</span><span class="params">(SeqStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack s;</span><br><span class="line">    InitStack(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入入栈元素：\n&quot;</span>);</span><br><span class="line">    StackInput(&amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈中元素为：\n&quot;</span>);</span><br><span class="line">    Display(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素为：\n&quot;</span>);</span><br><span class="line">    StackGetTop(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈中元素个数为:\n&quot;</span>);</span><br><span class="line">    StackLength(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;退一次栈!\n&quot;</span>);</span><br><span class="line">    StackPop(&amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈中元素为：\n&quot;</span>);</span><br><span class="line">    Display(s);</span><br><span class="line">    StackClear(&amp;s);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是定义结构体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SElemType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="comment">//栈数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base;<span class="comment">//栈底指针 不变</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针 一直在栈顶元素上一个位置</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;<span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="comment">//**************************************基本操作函数************************************//</span></span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.base=<span class="keyword">new</span> SElemType[MaxSize];<span class="comment">//动态分配最大容量</span></span><br><span class="line">    <span class="keyword">if</span>(!s.base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.top=s.base;<span class="comment">//栈顶指针与栈底相同 王道上top起初在base下面，感觉很别扭，top应该高于或等于base</span></span><br><span class="line">    s.stacksize=MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;s,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top-s.base==s.stacksize) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满</span></span><br><span class="line">    *(s.top++)=e;<span class="comment">//先入栈，栈顶指针再上移 注意与王道上的不同，具体问题具体分析</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈 用e返回值</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;s,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==s.base) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空</span></span><br><span class="line">    e=*--s.top;<span class="comment">//先减减 指向栈顶元素，再给e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到栈顶元素，不修改指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack s,SElemType &amp;e)</span> <span class="comment">//严蔚敏版59页有问题，应该用e去获得，函数返回bool类型去判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==s.base) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈空			</span></span><br><span class="line">    <span class="keyword">else</span> e=*--s.top;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//********************************功能实现函数**************************************//</span></span><br><span class="line"><span class="comment">//菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********1.入栈      2.出栈*********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********3.取栈顶    4.退出*********\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈功能函数 调用Push函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushToStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;SElemType e;<span class="keyword">int</span> flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入入栈元素个数(&gt;=1)：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个元素的值:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);</span><br><span class="line">        flag=Push(s,e);</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;%d已入栈\n&quot;</span>,e);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">&quot;栈已满！！！\n&quot;</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈功能函数 调用Pop函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopFromStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;SElemType e;<span class="keyword">int</span> flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入出栈元素个数(&gt;=1)：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=Pop(s,e);</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;%d已出栈\n&quot;</span>,e);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">&quot;栈已空！！！\n&quot;</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取栈顶功能函数 调用GetTop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTopOfStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SElemType e;<span class="keyword">bool</span> flag; </span><br><span class="line">    flag=GetTop(s,e);</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;栈顶元素为:%d\n&quot;</span>,e);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;栈已空！！！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack s;<span class="keyword">int</span> choice;</span><br><span class="line">    InitStack(s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入菜单序号：\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">        <span class="keyword">if</span>(choice==<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span>(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:PushToStack(s);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:PopFromStack(s);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:GetTopOfStack(s);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;输入错误！！！\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-链栈及基本操作"><a href="#3-3-链栈及基本操作" class="headerlink" title="3.3 链栈及基本操作"></a>3.3 链栈及基本操作</h2><p>把栈顶放在单链表的表头，用链表来存储栈的数据结构称为链栈。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/20/164b52876589ba10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="123" style="zoom:80%;" /></p>
<p>链栈节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-链栈的操作"><a href="#3-3-1-链栈的操作" class="headerlink" title="3.3.1 链栈的操作"></a>3.3.1 链栈的操作</h3><p>链栈也有四个元素，包括两个状态和两个操作</p>
<p>状态：</p>
<p>1）栈空：<code>StakNode-&gt;next == NULL</code>，即栈没有后继节点时，栈为空</p>
<p>2）栈满：如果存储空间无限大，没有这种情况。</p>
<p>操作：</p>
<p>进栈是头插法建立链表的插入方法，出栈就是单链表的删除操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1620868011-image-20210513090651272.png" alt="image-20210513090651272" style="zoom: 80%;" /></p>
<p>以上是链栈的插入操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1620868285-image-20210513091125197.png" alt="image-20210513091125197" style="zoom: 80%;" /></p>
<p>以上是链栈的删除操作</p>
<ul>
<li>链栈初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造一个空栈S，栈顶指针置空</span></span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S,SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//栈顶插入元素e</span></span><br><span class="line">    p=<span class="keyword">new</span> StackNode;    <span class="comment">//创建新节点</span></span><br><span class="line">    p-&gt;data=e;          <span class="comment">//将新节点数据域置为e</span></span><br><span class="line">    p-&gt;next=S;          <span class="comment">//将新结点与头结点建立逻辑关系</span></span><br><span class="line">    S=p;                <span class="comment">//更新头结点的指向</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除S的栈顶元素，用e返回值</span></span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> ERROR;     <span class="comment">//栈空</span></span><br><span class="line">    e=S-&gt;data;            <span class="comment">//将栈顶元素赋给e</span></span><br><span class="line">    p=S;                  <span class="comment">//用p临时保存栈顶元素空间，以备释放</span></span><br><span class="line">    S=S-&gt;next;            <span class="comment">//修改栈顶指针</span></span><br><span class="line">    <span class="keyword">delete</span> p;             <span class="comment">//释放原栈顶元素的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取栈顶元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStackNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    LinkedStackNode *next;</span><br><span class="line">&#125;LinkedStackNode,*LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitLinkedStack</span><span class="params">(LinkedStack &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkedStackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStackNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestroyList</span><span class="params">(LinkedStack &amp;L)</span></span>&#123;</span><br><span class="line">    LinkedStack temp;</span><br><span class="line">    <span class="keyword">while</span>(L)&#123;</span><br><span class="line">        temp=L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        L=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkedStackEmpty</span><span class="params">(LinkedStack L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LinkedStack is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LinkedStack isn&#x27;t Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkedStack &amp;L,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    LinkedStack temp;</span><br><span class="line">    temp=(LinkedStackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStackNode));<span class="comment">//创建临时结点</span></span><br><span class="line">    temp-&gt;data=e;<span class="comment">//将e赋值给temp的数据域</span></span><br><span class="line">    temp-&gt;next=L-&gt;next;<span class="comment">//temp结点指向下一结点</span></span><br><span class="line">    L-&gt;next=temp;<span class="comment">//更改L结点的指向temp结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkedStack &amp;L,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    LinkedStack temp;</span><br><span class="line">    temp=L-&gt;next;</span><br><span class="line">    e=temp-&gt;data;</span><br><span class="line">    L-&gt;next=temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(LinkedStack L,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e=L-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;              <span class="comment">//记几个测试代码，可随意修改</span></span><br><span class="line">    <span class="keyword">int</span> n,i,e;</span><br><span class="line">    LinkedStackNode *top;</span><br><span class="line">    InitLinkedStack(top);</span><br><span class="line">    LinkedStackEmpty(top);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Push(top, i);</span><br><span class="line">    &#125;</span><br><span class="line">    Pop(top,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,e);</span><br><span class="line">    GetElem(top, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,e);</span><br><span class="line">    DestroyList(top);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-什么是队列"><a href="#3-4-什么是队列" class="headerlink" title="3.4 什么是队列"></a>3.4 什么是队列</h2><p>　　与栈不同的是，队列的两端都“开口”，要求数据只能从一端进，从另一端出。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/1I33AU8-0.gif" alt="1234"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常，称进数据的一端叫做“队尾”，出数据的一端叫做“队头”，添加数据叫做入队，出队列叫做出队</span><br></pre></td></tr></table></figure>
<p>队列遵循<font color="ff0000">先进先出的原则</font>，队列存储结构的实现有以下两种方式：</p>
<ul>
<li>顺序队列：在顺序表的基础上实现队列的结构</li>
<li>链队列：在链表的基础上实现队列结构</li>
</ul>
<h3 id="3-4-1-队列的顺序存储"><a href="#3-4-1-队列的顺序存储" class="headerlink" title="3.4.1 队列的顺序存储"></a>3.4.1 队列的顺序存储</h3><p>　　为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718dca693468461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="tt" style="zoom:50%;" /></p>
<p>由于顺序队列初始状态没有存储任何元素，因此 <code>top</code> 指针和 <code>rear</code> 指针重合，且由于顺序队列底层实现靠的是数组，因此 <code>top</code> 和 <code>rear</code> 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p>
<p>用顺序表来存储队列元素的数据结构称为队列的顺序存储结构，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[maxsize];	<span class="comment">//定义数组</span></span><br><span class="line">    <span class="keyword">int</span> front;			<span class="comment">//队首指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;			<span class="comment">//队尾指针</span></span><br><span class="line">&#125;SqQueue;				<span class="comment">//顺序队列定义</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-队列的链式存储结构"><a href="#3-4-2-队列的链式存储结构" class="headerlink" title="3.4.2 队列的链式存储结构"></a>3.4.2 队列的链式存储结构</h3><p>只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718dca6c2c29574?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style="zoom:50%;" /></p>
<p>如图所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。</p>
<ul>
<li>链式队列的结构定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;				<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指针域</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//队列的链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QNode *front;		<span class="comment">//队头指针</span></span><br><span class="line">    QNode *rear;		<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LiQueue;</span><br></pre></td></tr></table></figure>
<ul>
<li>链队的初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(LiQueue *&amp;lqu)</span></span>&#123;</span><br><span class="line">    lqu = (LiQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LiQueue));</span><br><span class="line">    lqu-&gt;front = lqu-&gt;real = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链队的入队操作：如下图，表示链队列依次入队{1,2,3}三个元素</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718dca6c2b715c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style="zoom:50%;" /></p>
<p>如上图所示，当有新的数据入队时，要以下3步操作</p>
<blockquote>
<ol>
<li>将该数据元素用节点包裹，例如新节点名称为 elem；</li>
<li>与 rear 指针指向的节点建立逻辑关系，即执行 rear-&gt;next=elem；</li>
<li>最后移动 rear 指针指向该新节点，即 rear=elem；</li>
</ol>
</blockquote>
<ul>
<li>链队的出队操作：当有元素出队时，按照“先进先出”的原则，只需要将存储该数据的结点以及它之前入队的元素结点按照顺序依次出队。出队的过程就是从链表头一次删除首节点的过程，现在我们需要将上图{1,2}两个元素出队，如下图</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718dca6c81237bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style="zoom:50%;" /></p>
<p>所以我们知道，需要以下3步操作</p>
<blockquote>
<ol>
<li>通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；</li>
<li>将 p 节点（即要出队的队头节点）从链表中摘除；</li>
<li>释放节点 p，回收其所占的内存空间；</li>
</ol>
</blockquote>
<h1 id="第四章-串、数组和广义表"><a href="#第四章-串、数组和广义表" class="headerlink" title="第四章 串、数组和广义表"></a>第四章 串、数组和广义表</h1><h2 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4 数组"></a>4.4 数组</h2><h3 id="4-4-1-数组的类型定义"><a href="#4-4-1-数组的类型定义" class="headerlink" title="4.4.1 数组的类型定义"></a>4.4.1 数组的类型定义</h3><p>　　数组是由类型相同的数据元素构成的有序集合，一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表。</p>
<h3 id="4-4-2-数组的顺序存储"><a href="#4-4-2-数组的顺序存储" class="headerlink" title="4.4.2 数组的顺序存储"></a>4.4.2 数组的顺序存储</h3><p>　　在Basic、Pascal、Java和C语言中，用的是以行序为主序的存储结构，而在FORTRAN语言中，用的是以列序为主序的存储结构。</p>
<p>　　假设每个数据元素占L个存储单元，则二维数组A[0..m-1,0..n-1]（即下标从0开始，共有m行n列）中任一元素a<sub>ij</sub>的存储位置可由下式确定</p>
<script type="math/tex; mode=display">LOC(i,j)=LOC(0,0)+(n{\times}i+j)L</script><p>式中，LOC(i,j)是a<sub>ij</sub>的存储位置；LOC(0,0)是a<sub>00</sub>的存储位置，即二维数组A的起始存储位置也称为基地址或基址。</p>
<p>得到一般推广情况，可以得到n维数组A[0..b<sub>1</sub>,0..b<sub>2</sub>,…,0..b<sub>n</sub>-1]的数据元素存储位置的计算公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}LOC(j_1,j_2,...,j_n)&=LOC(0,0,...,0)+(b_2{\times}...b_n{\times}j_1+b_3{\times}...{\times}b_n{\times}j_2+...+b_n{\times}j_{n-1}+j_n)L\\&=LOC(0,0,...,0)+\left(
 \sum_{i=1}^{n-1}{j_i}\prod_{k=i+1}^{n}{b_k}+j_n
  \right)L
  \end{aligned}</script><p>可缩写成</p>
<script type="math/tex; mode=display">
LOC(j_1,j_2,...,j_n)=LOC(0,0,...,0)+\sum_{i=1}^{n}c_ij_i</script><p>其中，c<sub>n</sub>=L，c<sub>i-1</sub>=b<sub>i</sub>*c<sub>i</sub>，1&lt;i&lt;=n</p>
<h3 id="4-4-3-特殊矩阵的压缩存储"><a href="#4-4-3-特殊矩阵的压缩存储" class="headerlink" title="4.4.3 特殊矩阵的压缩存储"></a>4.4.3 特殊矩阵的压缩存储</h3><p><strong>1 对称矩阵</strong></p>
<p>[特点]　　在n*n的矩阵a中，满足以下性质：</p>
<script type="math/tex; mode=display">
a_{ij}=a_{ji}(a{\le}i,j{\le}n)</script><p>[存储方法]　　只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)/2个元素空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617873987-image-20210408172627868.png" alt="image-20210408172627868"></p>
<script type="math/tex; mode=display">
k=\begin{cases}
\frac{i(i-1)}{2}+j-1,　i{\ge}j\\
\frac{j(j-1)}{2}+i-1,　j{\lt}i
\end{cases}</script><p><strong>2 三角矩阵</strong></p>
<p>[特点]　　对角线以下(或者以上)的数据元素(不包括对角线)全部为常数c。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617874886-image-20210408174126047.png" alt="image-20210408174126047"></p>
<p>[存储方法]　　重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[k]和矩阵元a<sub>ij</sub>之间的关系：</p>
<p>（1）上三角矩阵：</p>
<script type="math/tex; mode=display">
k=\begin{cases}
\frac{(i-1)\times(2n-i+2)}{2}+j-i　　　　i{\le}j\\
\frac{n(n+1)}{2}　　　　　　　　　　　　i{\gt}j
\end{cases}</script><p>（2）下三角矩阵：</p>
<script type="math/tex; mode=display">
k=\begin{cases}
\frac{i(i-1)}{2}+j-1　　　　i{\ge}j\\
\frac{n(n+1)}{2}　　　　　　　　i{\lt}j
\end{cases}</script><p><strong>3 对角矩阵</strong></p>
<p>[特点]　　在n*n的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内 — L对角矩阵。</p>
<p>[存储方法]</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617875446-image-20210408175046697.png" alt="image-20210408175046697" style="zoom:67%;" /></p>
<p><strong>4 稀疏矩阵</strong></p>
<p>[特点]　　大多数元素为0</p>
<p>[常用存储方法]　　只记录每一非零元素(i,j,a<sub>ij</sub>)</p>
<h1 id="第五章-树和二叉树"><a href="#第五章-树和二叉树" class="headerlink" title="第五章 树和二叉树"></a>第五章 树和二叉树</h1><h2 id="5-1-树和二叉树的定义"><a href="#5-1-树和二叉树的定义" class="headerlink" title="5.1 树和二叉树的定义"></a>5.1 树和二叉树的定义</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><p>　　树是n(n&gt;=0)个结点的有限集，它或为空树(n=0)；或为非空树，对于非空树T：</p>
<p>（1）有且仅有一个称之为根的结点；</p>
<p>（2）除根节点意外的其余结点可分为m（m&gt;0）个互不相交的有限集T<sub>1</sub>，T<sub>2</sub>，…，T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786835-image-20210407171355733.png" alt="image-20210407171355733" style="zoom:67%;" /></p>
<h3 id="5-1-2-树的基本术语"><a href="#5-1-2-树的基本术语" class="headerlink" title="5.1.2 树的基本术语"></a>5.1.2 树的基本术语</h3><p>如图5.1（b）：</p>
<p>　　（1）<strong>结点</strong>：数中的一个独立单元。包含一个数据元素及若干指向其子树的分支，如图的A、B、C、D等。</p>
<p>　　（2）<strong>结点的度</strong>：结点拥有的子树数。如，A的度是3，C的度是1，F的度是0。</p>
<p>　　（3）<strong>树的度</strong>：树内各结点度的最大值</p>
<p>　　（4）<strong>叶子</strong>：度为0的结点称为<strong>叶子或终端结点</strong>。比如，K、L、F、G、M、I、J都是树的叶子。</p>
<p>　　（5）<strong>非终端结点</strong>：度不为0<strong>的结点称为非终端结点或分支节点</strong>。除根结点之外，也叫内部节点。</p>
<p>　　（6）<strong>双亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。如，B的双亲为A，B的孩子有E和Ｆ。</p>
<p>　　（７）<strong>层次</strong>：结点的层次从根开始定义，根为第一层，根的孩子为第二层等等。</p>
<p>　　（8）<strong>树的深度</strong>：树中结点的最大层次称为树的深度或高度，上图树的深度为4。</p>
<h3 id="5-1-3-二叉树的定义"><a href="#5-1-3-二叉树的定义" class="headerlink" title="5.1.3 二叉树的定义"></a>5.1.3 二叉树的定义</h3><p>　　二叉树（Binary Tree）是n(n&gt;=0)个结点所构成的集合，它或为空树(n=0)；或为非空树，对于非空树T：</p>
<p>（1）有且仅有一个称之为根的结点；</p>
<p>（2）除根结点之外的其余结点分为两个互不相交的子集T<sub>1</sub>和T<sub>2</sub>，分别称为T的左子树和右子树，且T<sub>1</sub>和T<sub>2</sub>本身又都是二叉树。</p>
<p><strong>二叉树的基本特点</strong></p>
<ul>
<li>结点的度都&lt;=2</li>
<li>有序树（子树有序，不能颠倒）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617844641-image-20210408091721508.png" alt="image-20210408091721508" style="zoom:67%;" /></p>
<h2 id="5-2-二叉树的性质和存储结构"><a href="#5-2-二叉树的性质和存储结构" class="headerlink" title="5.2 二叉树的性质和存储结构"></a>5.2 二叉树的性质和存储结构</h2><h3 id="5-2-1-二叉树的性质"><a href="#5-2-1-二叉树的性质" class="headerlink" title="5.2.1 二叉树的性质"></a>5.2.1 二叉树的性质</h3><p><strong>性质1</strong> 在二叉树的第i层上至多有2<sup>i-1</sup>个节点（i&gt;=1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876251-image-20210408180411607.png" alt="image-20210408180411607" style="zoom:67%;" /></p>
<p><strong>性质2</strong> 深度为k的二叉树至多有2<sup>k</sup>-1个节点（k&gt;=1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876268-image-20210408180428251.png" alt="image-20210408180428251" style="zoom:67%;" /></p>
<p><strong>性质3</strong> 对任何一个二叉树T，如果其终端节点数为n<sub>0</sub>，度为2的节点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876291-image-20210408180451411.png" alt="image-20210408180451411" style="zoom:67%;" /></p>
<p><strong>特殊的二叉树</strong></p>
<p>（1）满二叉树：一个深度为k且有2<sup>k</sup>-1个结点的二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876532-image-20210408180852817.png" alt="image-20210408180852817" style="zoom: 80%;" /></p>
<p>（2）完全二叉树：深度为k的，有n个节点的二叉树，当且仅当其没一个节点斗鱼深度为k的满二叉树中编号从1至n的结点一一对应（且最后一层叶子不满，全部集中在左边）</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617876541-image-20210408180901861.png" alt="image-20210408180901861" style="zoom: 80%;" /></p>
<p><strong>性质4</strong> 具有n个结点的完全二叉树的深度为：</p>
<script type="math/tex; mode=display">
\left \lfloor \log_2n\right \rfloor+1</script><blockquote>
<script type="math/tex; mode=display">
\left \lfloor x\right \rfloor取不大于x的最大整数，\left \lceil x \right \rceil取不小于x的最小整数。</script></blockquote>
<p><strong>性质5</strong> 如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到第[log<sub>2</sub>n]+1层，每层从左到右),则对任一结点i（1&lt;=i&lt;=n),有：</p>
<p>（1）如果i＝1，则结点i无双亲，是二叉树的根；如果i&gt;1，则其双亲是结点[i/2]。</p>
<p> （2）如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；若2i==n，其左孩子是结点2i（i为最后一个非叶子结点）。</p>
<p> （3）如果2i＋1&gt;n，则结点i无右孩子；若2i＋1==n ，其右孩子是结点2i＋1（i为最后一个非叶子结点）。</p>
<h3 id="5-2-2-二叉树的存储结构"><a href="#5-2-2-二叉树的存储结构" class="headerlink" title="5.2.2 二叉树的存储结构"></a>5.2.2 二叉树的存储结构</h3><p><strong>1 顺序存储结构</strong></p>
<p><strong>2 链式存储结构</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786182-image-20210407170302561.png" alt="image-20210407170302561"></p>
<p>如图 1 所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，图 1 对应的链式存储结构如图 2 所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786227-image-20210407170347593.png" alt="image-20210407170347593"></p>
<p>由图 2 可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：</p>
<ul>
<li>指向左孩子节点的指针（Lchild）；</li>
<li>节点存储的数据（data）；</li>
<li>指向右孩子节点的指针（Rchild）；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617786252-image-20210407170412791.png" alt="image-20210407170412791"></p>
<p>表示该节点结构的 C 语言代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span>  </span><br><span class="line">    TElemType data;<span class="comment">//数据域   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span><span class="comment">//可以有可以没有</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-遍历二叉树和线索二叉树"><a href="#5-3-遍历二叉树和线索二叉树" class="headerlink" title="5.3 遍历二叉树和线索二叉树"></a>5.3 遍历二叉树和线索二叉树</h2><h3 id="5-3-1-遍历二叉树及其应用"><a href="#5-3-1-遍历二叉树及其应用" class="headerlink" title="5.3.1 遍历二叉树及其应用"></a>5.3.1 遍历二叉树及其应用</h3><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树由3个基本单元组成：根结点、左子树、右子树。因此可以分为三个遍历部分。可以参考具体<a target="_blank" rel="noopener" href="https://www.pianshen.com/article/7106254596/">链接</a>。</p>
<ul>
<li><p>DLR——先序遍历，先根再左再右</p>
</li>
<li><p>LDR——中序遍历，先左再根再右</p>
</li>
<li><p>LRD——后序遍历，先左再右再根</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1617788435-image-20210407174035666.png" alt="image-20210407174035666"></p>
<p><strong>先序遍历</strong></p>
<blockquote>
<p>先序遍历：访问根节点，访问当前节点的左子树；若当前节点无左子树，则访问当前节点的右子树。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053575-image-20210422090614930.png" alt="image-20210422090614930"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status PreOrder <span class="title">Traverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>中序遍历</strong></p>
<blockquote>
<p>中序遍历：访问当前节点的左子树；访问根节点；访问当前节点的右子树。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053611-image-20210422090651292.png" alt="image-20210422090651292"></p>
<p><strong>中序遍历的递归算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;</span><br><span class="line">        InorderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>中序遍历的非递归算法</strong></p>
<p>①初始化一个空栈S，指针p指向根结点</p>
<p>②申请一个结点空间q，用来存放栈顶弹出的元素</p>
<p>③当p非空或者栈S非空时，循环执行以下操作：</p>
<ul>
<li>如果p非空，则将p进栈，p指向该结点的左孩子；</li>
<li>如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    p=T;</span><br><span class="line">    q=<span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span>(p||!StackEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;<span class="comment">//p非空</span></span><br><span class="line">            Push(S,p);<span class="comment">//根指针进栈</span></span><br><span class="line">            p=p-&gt;lchild;<span class="comment">//根指针进栈，遍历左子树 </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//p空</span></span><br><span class="line">            Pop(S,q);<span class="comment">//退栈</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;q-&gt;data;<span class="comment">//访问根结点</span></span><br><span class="line">            p=q-&gt;rchild;<span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后序遍历</strong></p>
<blockquote>
<p>后序遍历：从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053789-image-20210422090949365.png" alt="image-20210422090949365"></p>
<p><strong>层序遍历</strong></p>
<blockquote>
<p>层次遍历：从上往下一层一层遍历。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619053809-image-20210422091009192.png" alt="image-20210422091009192"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelTreaverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;BiNode *&gt; que;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    que.push(T);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        BiNode *p = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            que.push(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">			que.push(p-&gt;rchild);v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的遍历应用"><a href="#二叉树的遍历应用" class="headerlink" title="二叉树的遍历应用"></a>二叉树的遍历应用</h4><ul>
<li><strong>先序遍历的顺序建立二叉链表</strong></li>
</ul>
<blockquote>
<p>1.扫描序列，读入字符ch。</p>
<p>2.如果ch是一个“#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：</p>
<p>①申请一个节点空间T；</p>
<p>②将ch赋给T-&gt;data;</p>
<p>③递归创建T的左子树；</p>
<p>④递归创建T的右子树；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//按先序次序输入二叉树中的结点的值，创建二叉链表表示二叉树T</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>; <span class="comment">//递归结束，建立空树</span></span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//递归创建二叉树</span></span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;<span class="comment">//生成根节点</span></span><br><span class="line">        T-&gt;data=ch;<span class="comment">//根结点数据域为ch</span></span><br><span class="line">        CreateBiTree(T-&gt;lchild);<span class="comment">//递归创建左子树</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild);<span class="comment">//递归创建右子树</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>复制二叉树</strong></li>
</ul>
<blockquote>
<p>①若二叉树不空，则首先复制根结点（相当于先序遍历算法中访问根节点的语句）</p>
<p>②然后分别复制二叉树根结点的左子树和右子树（相当于先序遍历中递归遍历左子树和右子树的语句）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        NewT=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>计算二叉树深度</strong></li>
</ul>
<blockquote>
<p>如果是空树，递归结束，深度为0，否则</p>
<ul>
<li>递归计算左子树的深度为m；</li>
<li>递归计算右子树的深度为n；</li>
<li>如果m&gt;n，二叉树的深度为m+1，否则n+1。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//计算二叉树T的深度</span></span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果是空树，深度为0, 递归结束</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=Depth(T-&gt;lchild);<span class="comment">//递归计算左子树的深度记为m</span></span><br><span class="line">        n=Depth(T-&gt;rchild);<span class="comment">//递归计算右子树的深度记为n</span></span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span>(m+l);<span class="comment">//二叉树的深度为m与n的较大者加1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>(n+l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                             </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>统计二叉树中结点的个数</strong></li>
</ul>
<blockquote>
<p>如果是空树，则结点个数为0,；苟泽，结点个数为左子树的结点个数加上右子树的结点个数再加上 1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//统计二叉树T中结点的个数</span></span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) <span class="keyword">return</span> O; <span class="comment">//如果是空树，则结点个数为0, 递归结束</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> NodeCount (T-&gt;lchild) +Node Count (T-&gt;rchild) + <span class="number">1</span>;<span class="comment">//否则结点个数为左子树的结点个数＋右子树的结点个数+l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>计算二叉树叶子结点的数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeadCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) 	<span class="comment">//如果是空树返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果是叶子结点返回1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> LeafCount(T-&gt;lchild) + LeafCount(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="ff000">在n个结点的二叉链表中，有n+1个空指针域</font>

<h3 id="5-3-2-线索二叉树"><a href="#5-3-2-线索二叉树" class="headerlink" title="5.3.2 线索二叉树"></a>5.3.2 线索二叉树</h3><p>　　遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。若将某种遍历序列某个结点的前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树。</p>
<p>如何保存这类信息？</p>
<script type="math/tex; mode=display">
两种解决方法=\begin{cases}
增加两个域：fwd和bwd;　　　使得结构的存储密度大大降低\\
\\
利用空链域（n+1个空链域）　　　　　　　　　　
\end{cases}</script><p>所以基于某种遍历规则：<br>1）若结点有左子树，则lchild指向其左孩子；<br>       否则， lchild指向其直接前驱(即线索)；</p>
<p>2）若结点有右子树，则rchild指向其右孩子；<br>       否则， rchild指向其直接后继(即线索) 。</p>
<font color ="#0000ff">为了避免混淆，增加两个标志域</font>

<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618393158-image-20210414173918248.png" alt="image-20210414173918248"></p>
<p>其中：</p>
<script type="math/tex; mode=display">
LTag=\begin{cases}
0　lchild域指示结点的左孩子　\\
1　lchild域指示结点的前驱　　　　　　　　　　
\end{cases}</script><script type="math/tex; mode=display">
RTag=\begin{cases}
0　lchild域指示结点的左孩子　\\
1　lchild域指示结点的后继　　　　　　　　　　
\end{cases}</script><p>二叉树二叉线索类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> LTag,RTag;</span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>
<p><strong>以结点p为根的子树中序线索化</strong></p>
<p>[算法步骤]</p>
<p>①如果p非空，左子树递归线索化</p>
<p>②如果p的左孩子为空，则给p加上左线索，将其LTag置为1，让p的左孩子指针指向pre（前驱）；否则将p的LTag置为0</p>
<p>③如果pre的右孩子为空，则给pre加上右线索，将其RTag置为1，让pre的右孩子指针指向p（后继）；否则将pre的RTag置为0</p>
<p>④将pre指向刚访问过的结点p，即pre=p</p>
<p>⑤右子树递归线索化</p>
<p>[算法描述]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//pre是全局变量，初始化时右孩子指针为空，便于在树的最左点开始建线索</span></span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        InThreading(p-&gt;lchild);<span class="comment">//左子树递归线索化</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//p的左孩子为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag=<span class="number">1</span>;<span class="comment">//给p加上左线索</span></span><br><span class="line">            p-&gt;lchild=pre;<span class="comment">//p的左孩子指针指向pre（前驱）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;LTag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild)&#123;<span class="comment">//pre的右孩子为空</span></span><br><span class="line">            pre-&gt;RTag=<span class="number">1</span>;<span class="comment">//给pre加上右线索</span></span><br><span class="line">            pre00&gt;rchild=p;<span class="comment">//pre的右孩子指针指向p（后继）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            pre-&gt;RTag=<span class="number">0</span>;</span><br><span class="line">        pre=p;<span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">        InThreading(p-&gt;rchild);<span class="comment">//右子树递归线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-树与森林"><a href="#5-4-树与森林" class="headerlink" title="5.4 树与森林"></a>5.4 树与森林</h2><h3 id="5-4-1-树的存储结构"><a href="#5-4-1-树的存储结构" class="headerlink" title="5.4.1 树的存储结构"></a>5.4.1 树的存储结构</h3><p><strong>1.双亲表示法</strong>：以一组连续空间存储树的结点，同时在结点中附设一个指针，存放双亲结点在链表中的位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618445484-image-20210415081124676.png" alt="image-20210415081124676" style="zoom:67%;" /></p>
<p>双亲实现树定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100   <span class="comment">//最大结点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span>          <span class="comment">//树结点定义</span></span><br><span class="line">    TElemType     data;                 </span><br><span class="line">    <span class="keyword">int</span>      parent;                        </span><br><span class="line">&#125; PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span>          <span class="comment">//树定义</span></span><br><span class="line">    PTNode   nodes[MAX_TREE_SIZE];                 </span><br><span class="line">    <span class="keyword">int</span>     r,   n;        <span class="comment">//根的位置和结点数                       </span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>
<p><strong>2.孩子表示法</strong>：</p>
<p>（1）多重链表法（两种）</p>
<p>（2）孩子链表法：将每个结点的孩子结点排列起来，看成一个线性表，且以单链表作存储结构，n个结点有n个孩子链表，n个头指针组成线性表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618445972-image-20210415081932478.png" alt="image-20210415081932478" style="zoom:67%;" /></p>
<p><strong>3.孩子兄弟表示法</strong>：每个节点除值域外，还包括两个指针，分别指向该节点的第一个孩子和下一个兄弟。</p>
<p>结点结构：<img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618446095-image-20210415082134980.png" alt="image-20210415082134980"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618446122-image-20210415082202662.png" alt="image-20210415082202662" style="zoom:67%;" /></p>
<p>结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125; CSNode ，*CSTree;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-森林和二叉树的转换"><a href="#5-4-2-森林和二叉树的转换" class="headerlink" title="5.4.2 森林和二叉树的转换"></a>5.4.2 森林和二叉树的转换</h3><p><strong>1.树—-&gt;二叉树</strong></p>
<blockquote>
<p>方法（树的孩子兄弟表示法）：</p>
<p>①加线：树中所有相邻兄弟间加一连线；<br>②抹线：对树中的每个结点，只保留其与第一个孩子间的连线，删去它与其他孩子间连线；<br>③旋转：以树根为轴心，将整棵树顺时针旋转45度，使之结构层次分明。 </p>
</blockquote>
<p>　　<font color="ff000">任何一棵树和树对应的二叉树，其根结点的右子树必空。</font></p>
<p>示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619055375-image-20210422093615176.png" alt="image-20210422093615176"></p>
<p>特点：</p>
<ul>
<li><p>左分支——-父子关系   右分支—-兄弟关系</p>
</li>
<li><p>根没有兄弟，所以一棵树转换后的二叉树一定只有左子树</p>
</li>
</ul>
<p><strong>2.森林—-&gt;二叉树</strong></p>
<p>方法：</p>
<p>①将森林中每棵树转换成相应的二叉树；<br>②第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连起来后，此时，所得二叉树即是森林转换得到的。</p>
<p>示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210603-image-20210603095305745.png" alt="image-20210603095305745" style="zoom:67%;" /></p>
<p><strong>3.二叉树—-&gt;树</strong></p>
<p>①若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；</p>
<p>②删除原二叉树中所有结点与其右孩子结点的连线；</p>
<p>③整理（1）和（2）两步得到的树，使之结构层次分明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210603-image-20210603093907428.png" alt="image-20210603093907428" style="zoom:67%;" /></p>
<p><strong>4.二叉树—-&gt;森林</strong></p>
<p>①先把每个结点与右孩子结点的连线删除，得到分离的二叉树；</p>
<p>②把分离后的每棵二叉树转换为树；</p>
<p>③整理第（2）步得到的树，使之规范，这样得到森林。</p>
<p>特点：根没有右孩子，则转换成的是树，否则转换成的是森林。</p>
<h3 id="5-4-3-森林和树的遍历"><a href="#5-4-3-森林和树的遍历" class="headerlink" title="5.4.3 森林和树的遍历"></a>5.4.3 森林和树的遍历</h3><p><strong>1.树的遍历</strong></p>
<ul>
<li><p>先根遍历：若树不空，则先访问根结点，然后依次从左到右先根遍历根的各棵子树。</p>
</li>
<li><p>后根遍历：若树不空，则先依次从左到右后根遍历根的<br> 各棵子树，然后访问根结点； </p>
</li>
</ul>
<p><strong>2.森林的遍历</strong></p>
<ul>
<li>先序遍历森林：</li>
</ul>
<p>若森林非空，则可按下述规则遍历：</p>
<p>①访问森林中第一棵树的根结点；</p>
<p>②先序遍历第一棵树的根结点的子树森林；</p>
<p>③先序遍历除去第一棵树之后剩余的树构成的森林。</p>
<ul>
<li>中序遍历森林</li>
</ul>
<p>若森林非空，则可按下述规则遍历：</p>
<p>①中序遍历森林中第一棵树的根结点的子树森林；</p>
<p>②访问第一棵树的根结点；</p>
<p>③中序遍历除去第一棵树之后剩余的树构成的森林。</p>
<h2 id="5-5-哈夫曼树及其应用"><a href="#5-5-哈夫曼树及其应用" class="headerlink" title="5.5 哈夫曼树及其应用"></a>5.5 哈夫曼树及其应用</h2><h3 id="5-5-1-哈夫曼树的基本概念"><a href="#5-5-1-哈夫曼树的基本概念" class="headerlink" title="5.5.1 哈夫曼树的基本概念"></a>5.5.1 哈夫曼树的基本概念</h3><p>　　哈夫曼树又称最优树，是一类带权路径长度最短的树。</p>
<p>（1）<strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</p>
<p>（2）<strong>路径长度</strong>：路径上的分支数目称作路径长度。</p>
<p>（3）<strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。</p>
<p>（4）<strong>权</strong>：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类， 所以对应有结点权和边权。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。</p>
<p>（5）<strong>结点的带权路径长度</strong>：从该结点到树根之间的路径长度与结点上权的乘积。</p>
<p>（6）<strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和，通常记作$WPL=\sum_{k=1}^{n}{w_k}{l_k}$</p>
<p>（7）<strong>哈夫曼树</strong>：假设有m个权值{$w_1,w_2,···,w_m$}，可以构造一颗含有n个叶子结点的二叉树，每个叶子结点的权为$w_i$，则其中带权路径长度WPL最小的二叉树称作最优二叉树或哈夫曼树。</p>
<h3 id="5-5-2-哈夫曼树的构造算法"><a href="#5-5-2-哈夫曼树的构造算法" class="headerlink" title="5.5.2 哈夫曼树的构造算法"></a>5.5.2 哈夫曼树的构造算法</h3><p><strong>1.哈夫曼树的构造过程</strong></p>
<p><strong>2.哈夫曼算法的实现</strong></p>
<p>由于哈夫曼树中没有度为1的结点，则一颗有n个叶子结点的哈夫曼树共有2n-1个结点。</p>
<p>哈夫曼树的存储表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;					<span class="comment">//结点的权值</span></span><br><span class="line">    <span class="keyword">int</span> parent,lchild,rchild;	<span class="comment">//结点的双亲、左孩子、右孩子</span></span><br><span class="line">&#125;*HuffmanTree;					<span class="comment">//动态分配数组存储哈夫曼树</span></span><br></pre></td></tr></table></figure>
<p><font color="ff000">为了实现方便，数组0号单元不使用，从1号单元开始使用，所以数组大小为2n</font>。叶子结点存储在前面部分1~n个位置，后面的n-1个位置存储其余非叶子结点。</p>
<p>构造哈夫曼树算法实现可以分为两部分：</p>
<p>①初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0,；最后循环n次，输入前n个单元中叶子结点的权值。</p>
<p>②创建树：循环n-1次，通过n01次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为0且权值最小的两个树根节点s1和s2；删除是指将结点s1和s2的双亲改为非0；合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个节点做孩子的下标为s1，右孩子的下标为s2。</p>
<h1 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h1><h2 id="6-1-图的定义和基本术语"><a href="#6-1-图的定义和基本术语" class="headerlink" title="6.1 图的定义和基本术语"></a>6.1 图的定义和基本术语</h2><h3 id="6-1-1-图的定义"><a href="#6-1-1-图的定义" class="headerlink" title="6.1.1 图的定义"></a>6.1.1 图的定义</h3><p>　　图由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有穷非空集合，E是V中顶点欧对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合。</p>
<p>　　无向图：每条边都没有方向</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618999001-image-20210421175641281.png" alt="image-20210421175641281"></p>
<p>　　有向图：每条边都有方向</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618998974-image-20210421175614149.png" alt="image-20210421175614149"></p>
<p>　　完全图：任意两点都有一条边相连</p>
<center class="half">   <img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618999143-image-20210421175903730.png " width="300"/> <img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1618999151-image-20210421175911065.png" width="300"/> </center>

<h3 id="6-1-2-图的基本术语"><a href="#6-1-2-图的基本术语" class="headerlink" title="6.1.2 图的基本术语"></a>6.1.2 图的基本术语</h3><p><strong>顶点的度：</strong>与该顶点相关联的边的数目，记为TD(v)。</p>
<p>　　在有向图中，顶点的度等于该顶点的入度与出度之和。</p>
<p>　　顶点v的<strong>入度是以v为终点</strong>的有向边的条数，记做ID(v)，</p>
<p>　　顶点v的<strong>出度是以v为始点</strong>的有向边的条数，记做OD(v)</p>
<ul>
<li>问：当有向图仅有1个顶点的入度为0，其余顶点的入度均为1，此时是何结构？</li>
<li>答：是一棵树；一颗有向树。</li>
</ul>
<p><strong>路径：</strong>连续的边构成的顶点序列。</p>
<p><strong>路径长度：</strong>路径上边或弧的数目/权值之和。</p>
<p><strong>回路(环)：</strong>第一个顶点和最后一个顶点相同的路径。</p>
<p><strong>简单路径：</strong>路径中各顶点均不相同的路径。</p>
<p><strong>简单回路(简单环)：</strong>除路径起点和终点相同外，其余顶点均不相同的路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599276-image-20210428164116694.png" alt="image-20210428164116694"></p>
<hr>
<p><strong>连通图（强连通图）：</strong>在无（有）向图G=( V, {E} )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599384-image-20210428164304480.png" alt="image-20210428164304480"></p>
<p><strong>连通分量：</strong>无向图G 的极大连通子图称为G的连通分量。极大连通子图意思是：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599429-image-20210428164349664.png" alt="image-20210428164349664"></p>
<p><strong>强连通分量：</strong>有向图G 的极大强连通子图称为G的强连通分量。极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599481-image-20210428164441752.png" alt="image-20210428164441752"></p>
<p><strong>子图：</strong>设有两个图G=（V，{E}）、G1=（V1，{E1}），若V1  V，E1  E，则称 G1是G的子图。例:(b)、(c) 是 (a) 的子图</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599589-image-20210428164628941.png" alt="image-20210428164628941"></p>
<p><strong>极小连通子图：</strong>该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。（n-1条边）</p>
<p><strong>生成树：</strong>包含无向图G 所有顶点的极小连通子图。</p>
<p><strong>生成森林：</strong>对非连通图，各个连通分量的生成树构成的集合。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619599660-image-20210428164740239.png" alt="image-20210428164740239"></p>
<h2 id="6-2-图的存储结构"><a href="#6-2-图的存储结构" class="headerlink" title="6.2 图的存储结构"></a>6.2 图的存储结构</h2><p>　　图没有顺序存储结构，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。另一方面，图的链式存储有邻接表、十字链表和邻接多重表。</p>
<h3 id="6-2-1-邻接矩阵"><a href="#6-2-1-邻接矩阵" class="headerlink" title="6.2.1 邻接矩阵"></a>6.2.1 邻接矩阵</h3><p><strong>顺序表（邻接矩阵）表示法</strong></p>
<p>①建立一个顶点表（记录各顶点信息）和一个邻接矩阵（表示各顶点之间关系）</p>
<p>②设图A=(V,E)有n个顶点，则图的邻接矩阵是一个二维数组A.Edge[n][n]定义为：</p>
<script type="math/tex; mode=display">
A.Edge[i][j]=\begin{cases}1,　　如果　<i,j>{\in}E　或者　(i,j){\in}E\\
0,　　反之
\end{cases}</script><p><strong>无向图的邻接矩阵表示法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619600884-image-20210428170804280.png" alt="image-20210428170804280"></p>
<blockquote>
<p>分析1：无向图的邻接矩阵是对称的；</p>
<p>分析2：顶点i 的度＝第 i 行 (列) 中1 的个数；</p>
<p>分析3：完全图的邻接矩阵中，对角元素为0，其余为1。</p>
</blockquote>
<p><strong>有向图的邻接矩阵表示法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619601939-image-20210428172539618.png" alt="image-20210428172539618"></p>
<p>注意：在有向图的邻接矩阵中，</p>
<p>　　　第i行含义：以结点$v_i$为尾的弧（即出度边）；</p>
<p>　　　第i列含义：以节点$v_i$为头的弧（即入度边）。</p>
<blockquote>
<p>分析1：有向图的邻接矩阵可能是不对称的。</p>
<p>分析2：顶点的出度=第i行元素之和</p>
<p>　　　　顶点的入度=第i列元素之和</p>
<p>　　　　顶点的度=第i行元素之和+第i列元素之和</p>
</blockquote>
<p><strong>网（有权图）的邻接矩阵表示法</strong></p>
<p>定义为：</p>
<script type="math/tex; mode=display">
N.Edge[i][j]=\begin{cases}
W_{ij}　　<v_i,v_j>或(v_i,V_j){\in}V_R\\
\infty　　　无边（弧）
\end{cases}</script><p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/1619655052-image-20210429081052350.png" alt="image-20210429081052350"></p>
<p><strong>邻接矩阵的存储表示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 3267<span class="comment">//表示极大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line">ttypedef <span class="keyword">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType vexxs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure>
<p><strong>算法：采用邻接矩阵表示法创建无向网</strong></p>
<blockquote>
<p>算法步骤：</p>
<p>①输入总顶点数和总边数</p>
<p>②依次输入店的信息存入顶点表中</p>
<p>③初始化邻接矩阵，使每个权值初始化为极大值。</p>
<p>④构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//依次输入点的信息</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.vexs[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//初始化邻接矩阵，边的权值均值为极大值MaxInt</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G&gt;vexnum;j++)</span><br><span class="line">            G.arcs[i][j]=MaxInt;<span class="comment">//构造邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g.arcnum;k++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i=LocateVex(G,v1);j=LocateVex(G,v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标</span></span><br><span class="line">        G.arcs[i][j]=w;<span class="comment">//边&lt;v1,v2&gt;的权值为w</span></span><br><span class="line">        G.arcs[j][i]=G.arcs[i][j];<span class="comment">//置&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;的权值为w</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>算法分析</p>
<p>该算法的时间复杂度是$O(n^2)$。</p>
</blockquote>
<h3 id="6-2-2-链式存储结构"><a href="#6-2-2-链式存储结构" class="headerlink" title="6.2.2  链式存储结构"></a>6.2.2  链式存储结构</h3><ul>
<li><p>邻接表</p>
</li>
<li><p>十字链表</p>
</li>
<li><p>邻接多重表</p>
</li>
</ul>
<h2 id="6-3-图的遍历"><a href="#6-3-图的遍历" class="headerlink" title="6.3 图的遍历"></a>6.3 图的遍历</h2><h3 id="6-3-1-深度优先搜索"><a href="#6-3-1-深度优先搜索" class="headerlink" title="6.3.1 深度优先搜索"></a>6.3.1 深度优先搜索</h3><p>对于一个连通图，深度优先搜索遍历的过程如下：</p>
<blockquote>
<p>①从图中某个顶点v出发，访问v。</p>
<p>②找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问的顶点没有被访问的邻接点为止。</p>
<p>③返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</p>
<p>④重复步骤②和③，直至图中所有顶点都被访问过，搜索结束。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210602-image-20210602230209346.png" alt="image-20210602230209346" style="zoom: 33%;" /></p>
<p>访问顺序是：$v_1-&gt;v_2-&gt;v_4-&gt;v_8-&gt;v_5-&gt;v_3-&gt;v_6-&gt;v_7$</p>
<h3 id="6-3-2-广度优先搜索"><a href="#6-3-2-广度优先搜索" class="headerlink" title="6.3.2 广度优先搜索"></a>6.3.2 广度优先搜索</h3><p>广度优先搜索遍历过程如下：</p>
<blockquote>
<p>①从图中某个顶点v出发，访问v。</p>
<p>②依次访问v的各个未被访问过的邻接点。</p>
<p>③分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤③，直至图中所有已被访问的顶点的邻接点都被访问到。</p>
</blockquote>
<p>图6.17访问顺序：$v_1-&gt;v_2-&gt;v_3-&gt;v_4-&gt;v_5-&gt;v_6-&gt;v_7-&gt;v_8$</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210602-image-20210602230310978.png" alt="image-20210602230310978" style="zoom:67%;" /></p>
<h2 id="6-4-图的应用"><a href="#6-4-图的应用" class="headerlink" title="6.4 图的应用"></a>6.4 图的应用</h2><h1 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h1><h2 id="7-1-查找的基本概念"><a href="#7-1-查找的基本概念" class="headerlink" title="7.1 查找的基本概念"></a>7.1 查找的基本概念</h2><ul>
<li><p>查找表:</p>
<p>　由同一类型的数据元素（或记录）构成的集合</p>
</li>
<li><p>静态查找表：</p>
<p>　查找的同时对查找表不做修改操作（如插入和删除）</p>
</li>
<li><p>动态查找表：</p>
<p>　查找的同时对查找表具有修改操作</p>
</li>
<li><p>关键字</p>
<p>　记录中某个数据项的值，可用来识别一个记录</p>
</li>
<li><p>主关键字：</p>
<p>　唯一标识数据元素的值</p>
</li>
<li><p>次关键字：<br>　可以标识若干个数据元素</p>
</li>
<li><p>平均查找长度（关键字的平均比较次数）</p>
</li>
</ul>
<script type="math/tex; mode=display">
ASL=\sum_{i=1}^{n}p_ic_i</script><p>n：记录的个数</p>
<p>$p_i$：查找第i个记录的概率（通常认为$p_i$=1/n）</p>
<p>$c_i$：找到第i个记录所需的比较次数</p>
<h2 id="7-2-线性表的查找"><a href="#7-2-线性表的查找" class="headerlink" title="7.2 线性表的查找"></a>7.2 线性表的查找</h2><h3 id="7-2-1-顺序查找"><a href="#7-2-1-顺序查找" class="headerlink" title="7.2.1 顺序查找"></a>7.2.1 顺序查找</h3><p>顺序查找适用于顺序结构，也适用于链式结构</p>
<p>数据元素类型的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType otherindo;</span><br><span class="line">&#125;ElemType;</span><br></pre></td></tr></table></figure>
<p>顺序表的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *R;<span class="comment">//表示基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//表示长度</span></span><br><span class="line">&#125;SSTable</span><br></pre></td></tr></table></figure>
<p>算法步骤：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ST.R[<span class="number">0</span>].key=key;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.R[i].key!=key;--i)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法的时间复杂度是O(n)</p>
<p>平均查找长度：$ASL=\frac{1}{n}\sum_{i=1}^{n}i=\frac{n+1}{2}$</p>
<h3 id="7-2-2-折半查找"><a href="#7-2-2-折半查找" class="headerlink" title="7.2.2 折半查找"></a>7.2.2 折半查找</h3><p>只适用于顺序结构</p>
<p>算法步骤：</p>
<blockquote>
<p>①置查找区间初值，low为1，high为表长</p>
<p>②当low小于等于high时，循环执行以下操作</p>
<ul>
<li>mid取值为low和high的中间值</li>
<li>将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid；</li>
<li>若不想等则利用中间位置记录将表对分成前、后两个子表。如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1。</li>
</ul>
<p>③循环结束，说明查找区间为空，则查找失败，返回0。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,KeyType key)</span></span>&#123;</span><br><span class="line">    low=<span class="number">1</span>;high=ST.length;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key==ST.R[mid].key) </span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">            (key&lt;ST.R[mid].key) high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是$O(log_2n)$</p>
<p>平均查找长度：$ASL=\sum<em>{i=1}^{n}P_iC_i=\frac{1}{n}\sum</em>{j=1}^{h}j·2^{j-1}=\frac{n+1}{n}log_2(n+1)-1$</p>
<p>当n较大时近似为：$ASL=log_2(n+1)-1$</p>
<h3 id="7-2-3-分块查找"><a href="#7-2-3-分块查找" class="headerlink" title="7.2.3 分块查找"></a>7.2.3 分块查找</h3><h2 id="7-3-树表的查找"><a href="#7-3-树表的查找" class="headerlink" title="7.3 树表的查找"></a>7.3 树表的查找</h2><h3 id="7-3-1-二叉排序树"><a href="#7-3-1-二叉排序树" class="headerlink" title="7.3.1 二叉排序树"></a>7.3.1 二叉排序树</h3><p>二叉排序树或是空树，或是满足如下性质的二叉树：</p>
<p> (1)若其左子树非空，则左子树上所有结点的值均小于根结点的值；</p>
<p> (2)若其右子树非空，则右子树上所有结点的值均大于等于根结点的值；</p>
<p> (3)其左右子树本身又各是一棵二叉排序树</p>
<p>结点的数据域的类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Struct&#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    IndoType otherindo;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br></pre></td></tr></table></figure>
<p><strong>算法7.4 二叉排序树的递归查找</strong></p>
<blockquote>
<p>①若二叉排序树为空，则查找失败，返回空指针。</p>
<p>②若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较：</p>
<ul>
<li>若key等于T-&gt;data.key，则查找成功，返回根节点地址</li>
<li>若key小于T-&gt;data.key，则递归查找左子树</li>
<li>若key大于T-&gt;data.key，则递归查找右子树</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((!T) || key==T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-2-平衡二叉树"><a href="#7-3-2-平衡二叉树" class="headerlink" title="7.3.2 平衡二叉树"></a>7.3.2 平衡二叉树</h3><p><strong>1.AVL树简介</strong></p>
<blockquote>
<p>AVL树的名字来源于它的发明作者G.M. Adelson-Velsky 和 E.M. Landis。AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）。</p>
<p>平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</p>
</blockquote>
<p>平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：</p>
<p>　1.左子树和右子树也是平衡二叉树</p>
<p>　2.每个结点的左子树和右子树高度差最多为1</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210526-image-20210526175341516.png" alt="image-20210526175341516"></p>
<p>图一中左边二叉树的节点45的左孩子46比45大，不满足二叉搜索树的条件，因此它也不是一棵平衡二叉树。</p>
<p>右边二叉树满足二叉搜索树的条件，同时它满足条件二，因此它是一棵平衡二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527080726469.png" alt="image-20210527080726469"></p>
<p>左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2，不满足条件二；</p>
<p>右边二叉树的节点均满足左右子树高度差至多为1，同时它满足二叉搜索树的要求，因此它是一棵平衡二叉树。</p>
<p>AVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），这得益于它时刻维护着二叉树的平衡。如果我们需要查找的集合本身没有顺序，在频繁查找的同时，也经常的插入和删除，AVL树是不错的选择。不平衡的二叉查找树在查找时的效率是很低的，因此，AVL如何维护二叉树的平衡是我们的学习重点。</p>
<p><strong>2.AVL树相关概念</strong></p>
<ol>
<li><p>平衡因子：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。</p>
<p> 在图二右边的AVL树上：</p>
<p> 节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1；</p>
<p> 节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1；</p>
<p> 节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0；</p>
<p> 节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1；</p>
<p> 对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。</p>
</li>
<li><p>最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树.。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081029408.png" alt="image-20210527081029408"></p>
</li>
</ol>
<p>在图三中，左边二叉树的节点45的BF = 1，插入节点43后，节点45的BF = 2。节点45是距离插入点43最近的BF不在[-1,1]范围内的节点，因此以节点45为根的子树为最小不平衡子树。</p>
<p><strong>3.AVL树的平衡调整</strong></p>
<p>定义平衡二叉树结点结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>
<p>整个实现过程是通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。分为LL型、RR型、LR型和RL型4种类型，各调整方法如下(下面用A表示最低不平衡结点)：</p>
<ol>
<li>LL型调整：</li>
</ol>
<blockquote>
<p>由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081355420.png" alt="image-20210527081355420"></p>
<blockquote>
<p>LL型调整的一般形式如下图2所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：==①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。==</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081640790.png" alt="image-20210527081640790"></p>
<p>代码实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081706164.png" alt="image-20210527081706164"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">ll_rotate</span><span class="params">(BTNode *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;   </span><br><span class="line"> </span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>RR型调整：</li>
</ol>
<blockquote>
<p>由于在A的右孩子(R)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图3是RR型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B逆时针旋转一样。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081850609.png" alt="image-20210527081850609"></p>
<blockquote>
<p>RR型调整的一般形式如下图4所示，表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：</p>
<p>将A的右孩子B提升为新的根结点；<br>将原来的根结点A降为B的左孩子<br>各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081924315.png" alt="image-20210527081924315"></p>
<p>代码实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527081948695.png" alt="image-20210527081948695"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">rr_rotate</span><span class="params">(struct Node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>LR型调整</li>
</ol>
<blockquote>
<p>由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082030489.png" alt="image-20210527082030489"></p>
<blockquote>
<p>LR型调整的一般形式如下图6所示，表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082102010.png" alt="image-20210527082102010"></p>
<p>代码实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082126473.png" alt="image-20210527082126473"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">lr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x = y-&gt;left;</span><br><span class="line">    y-&gt;left = rr_rotate(x);</span><br><span class="line">    <span class="keyword">return</span> ll_rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>RL型调整：</li>
</ol>
<blockquote>
<p>由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082230583.png" alt="image-20210527082230583"></p>
<blockquote>
<p>RL型调整的一般形式如下图8所示，表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：==①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。==</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082324312.png" alt="image-20210527082324312"></p>
<p>代码实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527082352452.png" alt="image-20210527082352317"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">lr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x = y-&gt;left;</span><br><span class="line">    y-&gt;left = rr_rotate(x);</span><br><span class="line">    <span class="keyword">return</span> ll_rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入和删除完整代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct Node *N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> N-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> =</span> (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;height = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">ll_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"></span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">rr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line"></span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(BTNode* N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> height(N-&gt;left) - height(N-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function">BTNode* <span class="title">insert</span><span class="params">(BTNode* node, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    node-&gt;height = <span class="number">1</span> + max(height(node-&gt;left), height(node-&gt;right));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)     <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key)     <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;left = rr_rotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key)     <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;right = ll_rotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BTNode * <span class="title">minValueNode</span><span class="params">(BTNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* current = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">BTNode* <span class="title">deleteNode</span><span class="params">(BTNode* root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;left == <span class="literal">NULL</span>) || (root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *root = *temp;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = minValueNode(root-&gt;right);</span><br><span class="line"></span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line"></span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    root-&gt;height = <span class="number">1</span> + max(height(root-&gt;left), height(root-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="number">0</span>) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="number">0</span>) <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = rr_rotate(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="number">0</span>)  <span class="comment">//Rl型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = ll_rotate(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;key);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    root = insert(root, <span class="number">9</span>);</span><br><span class="line">    root = insert(root, <span class="number">5</span>);</span><br><span class="line">    root = insert(root, <span class="number">10</span>);</span><br><span class="line">    root = insert(root, <span class="number">0</span>);</span><br><span class="line">    root = insert(root, <span class="number">6</span>);</span><br><span class="line">    root = insert(root, <span class="number">11</span>);</span><br><span class="line">    root = insert(root, <span class="number">-1</span>);</span><br><span class="line">    root = insert(root, <span class="number">1</span>);</span><br><span class="line">    root = insert(root, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历：\n&quot;</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The constructed AVL Tree would be</span></span><br><span class="line"><span class="comment">                     9</span></span><br><span class="line"><span class="comment">                    /  \</span></span><br><span class="line"><span class="comment">                   1    10</span></span><br><span class="line"><span class="comment">                 /  \     \</span></span><br><span class="line"><span class="comment">                0    5     11</span></span><br><span class="line"><span class="comment">               /    /  \</span></span><br><span class="line"><span class="comment">              -1   2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    root = deleteNode(root, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* The AVL Tree after deletion of 10</span></span><br><span class="line"><span class="comment">                       1</span></span><br><span class="line"><span class="comment">                     /   \</span></span><br><span class="line"><span class="comment">                    0     9</span></span><br><span class="line"><span class="comment">                  /     /  \</span></span><br><span class="line"><span class="comment">                -1     5     11</span></span><br><span class="line"><span class="comment">                     /  \</span></span><br><span class="line"><span class="comment">                    2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历：\n&quot;</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-B-树"><a href="#7-3-3-B-树" class="headerlink" title="7.3.3 B-树"></a>7.3.3 B-树</h3><h1 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h1><p>以下算法都会用到的类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;					<span class="comment">//关键字项</span></span><br><span class="line">    InfoType otherinfo;				<span class="comment">//其他数据项</span></span><br><span class="line">&#125;RedType;							<span class="comment">//记录类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    RedType r[MAXSIZE+<span class="number">1</span>];			<span class="comment">//r[0]闲置或用做哨兵单元</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>所有排序算法比较：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527094036260.png" alt="image-20210527094036260"></p>
<h2 id="8-1-插入排序"><a href="#8-1-插入排序" class="headerlink" title="8.1 插入排序"></a>8.1 插入排序</h2><h3 id="8-1-1-直接插入方法排序"><a href="#8-1-1-直接插入方法排序" class="headerlink" title="8.1.1 直接插入方法排序"></a>8.1.1 直接插入方法排序</h3><p>基本操作是将一条记录插入到已排好序的有序表中，从而得到一个新的、记录数量增1的有序表。</p>
<h3 id="8-1-2-折半插入排序"><a href="#8-1-2-折半插入排序" class="headerlink" title="8.1.2 折半插入排序"></a>8.1.2 折半插入排序</h3><h3 id="8-1-3-希尔排序"><a href="#8-1-3-希尔排序" class="headerlink" title="8.1.3 希尔排序"></a>8.1.3 希尔排序</h3><p><strong>1.基本概念</strong></p>
<blockquote>
<p>希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。</p>
<p>希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。</p>
<p>它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。</p>
</blockquote>
<p><strong>2.适用说明</strong></p>
<p>希尔排序时间复杂度是$O(n^{\frac{3}{2}})$，空间复杂度是$O(1)$，==只能用于顺序结构，不适用于链式结构==</p>
<p><strong>3.过程演示</strong></p>
<p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量$gap=\frac{length}{2}$，缩小增量继续以$gap=\frac{gap}{2}$的方式，这种增量选择我们可以用一个序列来表示，{$\frac{n}{2},\frac{\frac{n}{2}}{2},…,1$}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>如图所示：</p>
<p>（1）初始增量第一趟$gap=\frac{length}{2}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527091618326.png" alt="image-20210527091618326" style="zoom:80%;" /></p>
<p>（2）第二趟，增量缩小为2</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527091709212.png" alt="image-20210527091709212" style="zoom:80%;" /></p>
<p>（3）第三趟，增量缩小为1，得到最终结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/qnjy/images/data/20210527-image-20210527091738713.png" alt="image-20210527091738713" style="zoom:80%;" /></p>
<p>算法伪码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(SqlList &amp;L, <span class="keyword">int</span> dk)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对顺序表L做一趟增量是dk的希尔排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=dk+<span class="number">1</span>;i&lt;=L.length;++i)</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key&lt;L.r[i-dk].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span> &amp;&amp; L.r[<span class="number">0</span>].key&lt;L.r[j].key;j-=dk)		<span class="comment">//记录后移，直到找到插入位置</span></span><br><span class="line">                L.r[j+dk]=L.r[j];								<span class="comment">//将r[0]即原r[i]，插入到正确位置</span></span><br><span class="line">            L.r[j+dk]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> dt[],<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//按增量序列dt[0...t-1]对顺序表L作希尔排序</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;t;++k)</span><br><span class="line">        ShellInsert(L,dt[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-1-冒泡排序"><a href="#8-2-1-冒泡排序" class="headerlink" title="8.2.1 冒泡排序"></a>8.2.1 冒泡排序</h3><h3 id="8-2-2-快速排序"><a href="#8-2-2-快速排序" class="headerlink" title="8.2.2 快速排序"></a>8.2.2 快速排序</h3><h2 id="8-3-选择排序"><a href="#8-3-选择排序" class="headerlink" title="8.3 选择排序"></a>8.3 选择排序</h2><h3 id="8-3-1-简单选择排序"><a href="#8-3-1-简单选择排序" class="headerlink" title="8.3.1 简单选择排序"></a>8.3.1 简单选择排序</h3><h3 id="8-3-2-树形选择排序"><a href="#8-3-2-树形选择排序" class="headerlink" title="8.3.2 树形选择排序"></a>8.3.2 树形选择排序</h3><h3 id="8-3-3-堆排序"><a href="#8-3-3-堆排序" class="headerlink" title="8.3.3 堆排序"></a>8.3.3 堆排序</h3>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="qnjy 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="qnjy 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/9af0416b.html" rel="prev" title="JPA框架学习">
                  <i class="fa fa-chevron-left"></i> JPA框架学习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/282276cb.html" rel="next" title="BUUCTF_Web">
                  BUUCTF_Web <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qnjy</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  




  <script src="/js/local-search.js"></script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  





</body>
</html>
